<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DeadlineNoon — SuperContest Survivor</title>
<link rel="icon" type="image/svg+xml" href="logo-supercontest.svg" />
<style>
:root{--bg:#0f1115;--panel:#151826;--ink:#e7e9ee;--muted:#9aa3b2;--accent:#7c5cff;--line:#262a3b;--good:#2ecc71;--bad:#ff6b6b;--warn:#f1c40f;--info:#4da3ff}
*{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
.wrap{max-width:1300px;margin:0 auto;padding:24px}
header{display:flex;justify-content:space-between;align-items:center;gap:16px;margin-bottom:16px;flex-wrap:wrap}
.home-link{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.04);color:inherit;text-decoration:none;font-weight:600;font-size:13px}
.home-link:focus-visible{outline:2px solid var(--accent);outline-offset:4px}
.brand-stack{display:flex;flex-direction:column;gap:6px;flex:1;min-width:220px}
.logo-wrap{display:flex;align-items:center;gap:8px}
.home-logo-media{display:block;width:108px;height:72px;border-radius:16px;object-fit:contain;box-shadow:0 10px 25px rgba(0,0,0,.35);background:#ffffff;padding:6px}
.meta-pills{display:flex;flex-wrap:wrap;gap:8px}
.meta-pill{display:inline-flex;align-items:center;gap:6px;padding:5px 12px;border-radius:999px;border:1px solid var(--line);background:linear-gradient(135deg,rgba(124,92,255,.25),rgba(124,92,255,.05));box-shadow:0 4px 12px rgba(0,0,0,.25);font-size:13px;color:var(--ink)}
.meta-pill .count{font-weight:700;font-size:15px}
.meta-pill .slash{opacity:.65;font-weight:600}
.meta-pill .label{font-size:12px;color:var(--muted)}
.implied-banner{display:inline-flex;align-items:center;gap:8px;padding:8px 16px;margin:0 0 16px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.03);font:600 14px/1.2 system-ui;letter-spacing:.2px;color:var(--muted)}
.status-grid{display:grid;gap:12px;margin:0 0 16px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
.status-card{border:1px solid var(--line);border-radius:12px;padding:12px;background:rgba(255,255,255,.03)}
.status-card .label{font-size:12px;text-transform:uppercase;letter-spacing:.35px;color:var(--muted)}
.status-card .value{font-weight:700;font-size:22px;margin-top:4px}
.status-card .note{margin-top:6px;font-size:12px;color:var(--muted)}
.rooting-panel{border:1px solid var(--line);border-radius:12px;padding:12px;margin-top:12px;background:rgba(255,255,255,.03);display:flex;flex-direction:column;gap:6px}
.rooting-panel .rooting-title{font-size:12px;text-transform:uppercase;letter-spacing:.35px;color:var(--muted);font-weight:600}
.rooting-panel .rooting-game{font-weight:600}
.rooting-panel .rooting-note{font-size:12px;color:var(--muted)}
.rooting-panel .rooting-action{font-size:13px;line-height:1.5}
.result-symbol{display:inline-block;margin-left:6px;font-weight:600}
.result-symbol.result-win{color:var(--good)}
.result-symbol.result-loss{color:var(--bad)}
.result-symbol.result-pending{color:var(--muted)}
.team-name{margin-left:6px;font-weight:600}
.team-name.strike{text-decoration:line-through;color:var(--muted)}
.chi-card{margin-top:16px;border:1px dashed var(--line);border-radius:12px;padding:12px;background:rgba(255,255,255,.03)}
.chi-grid{display:flex;flex-wrap:wrap;gap:12px}
.chi-grid label{display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted)}
.chi-grid input,.chi-grid select{min-width:140px;background:rgba(255,255,255,.04);border:1px solid var(--line);color:var(--ink);padding:6px 8px;border-radius:8px;font:inherit}
.chi-note{margin-top:8px;font-size:12px;color:var(--muted)}
#hedgeGrid{margin-top:12px}
.brand{font-weight:800;font-size:28px}.accent{color:var(--accent)}
.badge{border:1px solid var(--line);border-radius:999px;padding:6px 10px;color:var(--muted);font-size:12px}
.grid{display:grid;gap:16px}@media(min-width:1200px){.grid{grid-template-columns:2fr 1fr}}
.card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.08)),var(--panel);border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
h2{margin:0 0 10px}.sub{color:var(--muted);font-size:14px}
.row{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
select,textarea,button,input{background:rgba(255,255,255,.04);border:1px solid var(--line);color:var(--ink);padding:8px 10px;border-radius:10px;font:inherit}
button{cursor:pointer}
input{min-width:0}
table{width:100%;border-collapse:collapse}th,td{padding:10px;border-bottom:1px solid var(--line);vertical-align:middle}
th{text-align:left;font-size:12px;letter-spacing:.3px;text-transform:uppercase;color:var(--muted)}
tr:last-child td{border-bottom:0}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.pill{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:999px;padding:4px 10px;font-size:12px}
.chip{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:2px 8px;font-size:12px}
.chip.warn{color:var(--warn)}.chip.info{color:var(--info)}.chip.ok{color:var(--good)}.chip.bad{color:var(--bad)}
.muted{color:var(--muted)}footer{margin-top:16px;color:var(--muted);font-size:12px;text-align:center}
.scroll{max-height:520px;overflow:auto;border:1px solid var(--line);border-radius:12px}
.tiny{font-size:12px}
.legend{display:flex;gap:8px;flex-wrap:wrap}.legend .chip{border-style:dashed}
/* Compact tracker */
.trk-compact .rowline{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
.used-mini{display:flex;flex-wrap:wrap;gap:6px}
.u-chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.03)}
.u-chip .wk{font-size:11px;color:var(--muted)}
.toggle-btn{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:10px;padding:4px 10px;background:rgba(255,255,255,.04);color:var(--ink);cursor:pointer;font-size:12px}
.toggle-btn .chev{transition:transform .18s ease}
.toggle-btn[aria-expanded="true"] .chev{transform:rotate(90deg)}
.link-btn{background:none;border:0;padding:0;font:inherit;color:var(--accent);cursor:pointer;text-decoration:underline}
.link-btn:hover,.link-btn:focus{color:#fff}
.open-panel{color:var(--muted)}
.open-panel:hover,.open-panel:focus{color:var(--ink)}
.trk-panel{overflow:hidden;max-height:0;opacity:0;transition:max-height .25s ease,opacity .2s ease;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.08));border:1px solid var(--line);border-radius:12px;margin:8px 0;padding:0 12px}
.trk-panel.open{max-height:260px;opacity:1;padding:12px}
.trk-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.trk-col h4{margin:0 0 6px;font-size:12px;color:var(--muted);letter-spacing:.3px;text-transform:uppercase}
.chips{display:flex;flex-wrap:wrap;gap:6px}
.right-meta{display:flex;gap:8px;align-items:center}
.mutey{color:var(--muted);font-size:12px}
.logo{height:20px;width:20px;vertical-align:-4px;margin-right:6px;border-radius:2px;background:#0002}
.logo-lg{height:28px;width:28px;vertical-align:-6px;margin-right:8px;border-radius:4px;background:#0002}
.badge-inline{display:inline-flex;align-items:center;gap:6px}
.kit{display:flex;flex-wrap:wrap;gap:6px}
.kit .tile{display:flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:10px;padding:4px 8px}
.kit .used{opacity:.35}
.game-meta{display:flex;align-items:center;gap:6px;margin-top:6px}
.net-logo{width:20px;height:20px;display:inline-block;vertical-align:middle}
.net-badge{display:inline-flex;align-items:center;gap:4px;font:600 11px system-ui;padding:2px 6px;border-radius:999px;background:#f2f4f7;border:1px solid #d0d5dd;color:#111827}
.net-badge.thanksgiving{background:#fff4e6;border-color:#ffd7a3;color:#8b5e34}
.net-badge.tnf{background:#eef2ff;border-color:#c7d2fe;color:#3730a3}
.net-badge.black-friday{background:#111827;color:#f9fafb;border-color:#111827}
.net-badge.christmas{background:#e0f2f1;border-color:#99f6e4;color:#0f766e}
/* Hedge tab */
.hedge-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.box{border:1px solid var(--line);border-radius:12px;padding:12px;background:rgba(255,255,255,.03)}
.label{font-size:12px;color:var(--muted);margin-bottom:6px}
.stack{display:flex;flex-direction:column;gap:8px}
.row-gap{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.num{font-weight:700}
.hidden{display:none}
.warn{color:var(--warn)}
.note{font-size:12px;color:var(--muted)}
.is-locked{opacity:.3}
/* Tabs */
.tabs{display:flex;gap:8px;margin:0 0 12px}
.tabbtn{border:1px solid var(--line);border-radius:999px;padding:6px 12px;background:rgba(255,255,255,.03);cursor:pointer;color:var(--ink)}
.tabbtn.active{outline:2px solid var(--accent)}
.tabpage{display:none}
.tabpage.active{display:block}
.special-flag{display:inline-flex;align-items:center;gap:4px;margin-left:4px}
.special-toggle{background:rgba(255,255,255,.04);border:1px solid var(--line);color:var(--ink);width:22px;height:22px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;font-size:14px;line-height:1;padding:0;cursor:pointer}
.special-panel{display:none;margin:6px 0 0;padding:6px 8px;border:1px solid var(--line);border-radius:10px;background:rgba(255,255,255,.03);gap:6px;flex-wrap:wrap}
.special-panel.open{display:flex}
.special-team{display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border:1px solid var(--line);border-radius:999px;font-size:12px}
.special-team.used{opacity:.35}
.special-games-wrap{margin-top:12px}
.special-games-group{margin-bottom:12px}
.special-games-row{display:flex;flex-wrap:wrap;gap:12px}
.game-card{flex:1 1 220px;min-width:200px;background:rgba(255,255,255,.04);border:1px solid var(--line);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}
.game-header{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--muted)}
.game-icon{font-size:20px}
.game-body{display:flex;flex-direction:column;gap:6px}
.game-team{display:flex;align-items:center;gap:6px;font-weight:600}
.game-team.used{opacity:.35}
.special-focus-note{font-size:11px;color:var(--muted)}
.game-at{font-size:11px;color:var(--muted);text-align:center;letter-spacing:.6px;text-transform:uppercase}
#specialStatus tbody tr.focus td{background:rgba(255,255,255,.05)}
.chip.logo-chip{display:inline-flex;align-items:center;gap:6px;padding-right:10px}
.chip.dim{opacity:.35}
.chip .logo{margin-right:0}
.toggle-btn .chev{display:inline-block;transition:transform .2s ease}
.toggle-btn[aria-expanded="true"] .chev{transform:rotate(90deg)}
.avail-panel{display:none;margin-top:8px;padding:12px;border:1px solid var(--line);border-radius:12px;background:rgba(255,255,255,.03)}
.avail-panel.open{display:block}
.avail-grid{display:flex;flex-wrap:wrap;gap:16px}
.avail-col{flex:1 1 220px;min-width:200px}
.avail-col h4{margin:0 0 6px;font-size:13px;text-transform:uppercase;letter-spacing:.6px;color:var(--muted)}
.chips{display:flex;flex-wrap:wrap;gap:6px}
.chips .chip{border-style:dashed}
.root-card .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
.kpi{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(255,255,255,.03)}
.kpi .n{font-weight:700}
.root-table{width:100%;border-collapse:collapse;margin-top:8px}
.root-table th,.root-table td{padding:8px;border-bottom:1px solid var(--line)}
.root-table .used{opacity:.35}
.badge-good{color:var(--good)}
.badge-bad{color:var(--bad)}
.badge-warn{color:var(--warn)}
.ifttt{margin-top:10px;border:1px dashed var(--line);border-radius:12px;padding:10px}
.profit{color:var(--good)}
.loss{color:var(--bad)}
.hc-matchup{display:flex;align-items:center;gap:10px;margin-bottom:10px}
.hc-matchup .hc-team{display:flex;align-items:center;gap:6px;font-weight:600}
.hc-matchup .hc-vs{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.4px}
.is-locked{opacity:.45}
#hedgeWeek option.is-locked{color:#888}
.btn{appearance:none;border:0;border-radius:10px;padding:8px 12px;cursor:pointer;font:inherit}
.btn:focus{outline:2px solid var(--accent)}
.btn-primary{background:var(--accent);color:#fff}
.btn-secondary{background:rgba(255,255,255,.08);color:var(--ink);border:1px solid var(--line)}
.btn:disabled{opacity:.5;cursor:not-allowed}
.actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.explain{border:1px solid var(--line);border-radius:12px;background:rgba(255,255,255,.03);padding:10px}
.explain .headline{font-weight:700;margin-bottom:6px}
.explain .sub{font-size:12px;color:var(--muted)}
.callout{border-left:3px solid var(--accent);padding-left:10px;margin-top:8px}
.scs-card{margin-top:16px}
.scs-entries{display:flex;flex-direction:column;gap:6px}
.scs-entries h3{margin:0;font-size:16px}
.scs-entries .contest-note{font-size:12px;color:var(--muted)}
.scs-grid{width:100%;border-collapse:collapse;margin-top:6px}
.scs-grid th,.scs-grid td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;font-size:13px}
.scs-grid th{font-size:11px;letter-spacing:.35px;text-transform:uppercase;color:var(--muted)}
.scs-grid tbody tr:last-child td{border-bottom:0}
.scs-grid .col-w{width:7rem}
.scs-badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px;line-height:1.5;font-weight:600}
.scs-badge.win{background:rgba(46,204,113,.18);color:var(--good);border:1px solid rgba(46,204,113,.35)}
.scs-badge.pending{background:rgba(77,163,255,.15);color:#8bbefc;border:1px solid rgba(77,163,255,.35)}
.scs-badge.elim{background:rgba(255,107,107,.18);color:var(--bad);border:1px solid rgba(255,107,107,.35)}
.row-elim td{color:var(--muted)}
.row-elim td .struck{text-decoration:line-through;opacity:.6}
.status-ok{color:var(--good);font-weight:600}
.status-elim{color:var(--bad);font-weight:700}
.elim-toggle{display:flex;align-items:center;gap:10px;margin:12px 0 6px}
.elim-btn{background:rgba(255,107,107,.15);color:var(--bad);border:1px solid rgba(255,107,107,.35);border-radius:999px;padding:6px 12px;font-weight:700;cursor:pointer}
.elim-btn:focus{outline:2px solid rgba(255,107,107,.45)}
.elim-plus{margin-right:6px}
.elim-x{color:var(--bad);cursor:pointer;user-select:none}
.elim-panel{border:1px solid rgba(255,107,107,.3);border-radius:12px;padding:8px;background:rgba(255,255,255,.03)}
</style>
</head>
<body id="top">
<div class="wrap">
  <header>
    <a class="home-link" href="#top" aria-label="Back to top">Home</a>
    <div class="brand-stack">
      <div class="badge">Week <span id="hdr-week"></span> • <span id="hdr-date"></span></div>
      <div class="brand">Deadline<span class="accent">Noon</span> — SuperContest Survivor</div>
      <div class="meta-pills">
        <div class="meta-pill" id="activeHeadline">—</div>
      </div>
    </div>
    <div class="logo-wrap">
      <div class="badge mono" id="env-badge"></div>
      <img src="logo-supercontest.svg" alt="Westgate Las Vegas SuperContest Survivor" class="home-logo-media" />
    </div>
  </header>

  <div class="implied-banner" id="impliedBanner"></div>

  <div class="status-grid" id="status-cards">
    <div class="status-card" id="prize-pool">
      <div class="label">Prize Pool</div>
      <div class="value mono">—</div>
      <div class="note">Live entries: <span id="live-entries">—</span></div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tabbtn active" data-tab="overview">Overview</button>
    <button class="tabbtn" data-tab="rooting">Rooting</button>
    <button class="tabbtn" data-tab="hedge">Hedge</button>
  </div>

  <!-- ====== OVERVIEW PAGE ====== -->
  <div id="tab-overview" class="tabpage active">
  <div class="grid">
    <!-- LEFT: Tracker -->
    <section class="card">
      <div class="row">
        <div>
          <h2>Survivor Tracker</h2>
          <div class="legend">
            <span class="chip ok tiny">ACTIVE</span>
            <span class="chip bad tiny">ELIMINATED</span>
            <span class="chip warn tiny">About to pass 40% (special)</span>
            <span class="chip info tiny">≥40% used (special)</span>
          </div>
        </div>
        <div class="controls">
          <label class="tiny muted">Week <select id="weekSelect"></select></label>
          <button id="advanceWeek">Advance ➜</button>
          <span class="pill mono" id="activeCount"></span>
          <span class="pill mono" id="weekType"></span>
        </div>
      </div>

      <div class="scroll" style="margin-top:10px">
        <div class="mutey" id="densityWrap">
          <label class="tiny muted">Density
            <select id="trkDensity">
              <option value="comfort">Comfort</option>
              <option value="compact">Compact</option>
            </select>
          </label>
        </div>
        <table id="tracker" class="trk-compact">
          <thead><tr><th>Player</th><th class="mono" style="text-align:right">Summary</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <h3 style="margin-top:16px">Special Week Readiness</h3>
      <div class="tiny muted" style="margin-bottom:6px" data-special-help>If a player has no eligible team from a special set at that week, they’re auto-eliminated.</div>
      <div class="scroll">
        <table id="specialStatus">
          <thead><tr><th>Player</th><th>TG+BF</th><th></th><th>Christmas</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="specialGameCards" class="special-games-wrap"></div>
    </section>

    <!-- RIGHT: Rules + Make Picks -->
    <section class="card">
      <div class="row"><h2>Rules</h2><span class="chip">Implemented</span></div>
      <ul class="tiny">
        <li>Pick one team weekly; <strong>no reuse</strong> per entry.</li>
        <li><strong>Ties = losses</strong> (elimination).</li>
        <li><strong>Special weeks</strong> are independent: picks must come from that week’s set (TG+BF / XMAS).</li>
        <li>Auto-elimination at a special week if no team left from that set.</li>
        <li><strong>40% special-usage alerts</strong> (popup + badges): TG threshold 4/8; XMAS threshold 3/6.</li>
      </ul>

      <h3 style="margin-top:10px">Make Picks (Weeks 4+ or remaining W3)</h3>
      <div class="tiny muted" style="margin-bottom:6px">Choose a week, entry, then an <strong>available</strong> team (logos shown). Saved picks persist locally.</div>
      <div id="pickControls" class="controls" style="margin-bottom:8px">
        <label class="tiny muted">Week
          <select id="pickWeek"></select>
        </label>
        <label class="tiny muted">Entry
          <select id="pickPlayer"></select>
        </label>
        <label class="tiny muted">Team
          <select id="pickTeam"></select>
        </label>
        <button id="savePick">Save Pick</button>
      </div>
      <div id="availabilityTiles" class="kit"></div>

      <details style="margin-top:12px">
        <summary><strong>Data (read-only seed below; your edits persist locally)</strong></summary>
        <textarea id="dataEditor" rows="12" spellcheck="false" style="width:100%"></textarea>
      </details>

    </section>

    <section class="card scs-card">
      <div class="scs-entries">
        <h3>Entries — SuperContest Survivor</h3>
        <p class="contest-note">This section applies only to <strong>Westgate SuperContest Survivor</strong>. Do not mix with Circa.</p>

        <table class="scs-grid">
          <thead>
            <tr>
              <th>Entry</th>
              <th class="col-w">W1</th>
              <th class="col-w">W2</th>
              <th class="col-w">W3</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody id="scs-active-body"></tbody>
        </table>

        <div id="scs-elim-toggle" class="elim-toggle" hidden>
          <button type="button" id="scs-elim-btn" class="elim-btn" aria-expanded="false">
            <span class="elim-plus">+</span> Eliminated
          </button>
          <span class="elim-x" title="Show eliminated">✖</span>
        </div>

        <div id="scs-elim-panel" class="elim-panel" hidden>
          <table class="scs-grid">
            <thead>
              <tr>
                <th>Entry</th>
                <th class="col-w">W1</th>
                <th class="col-w">W2</th>
                <th class="col-w">W3</th>
                <th>Status</th>
                <th>Special Week Availability</th>
              </tr>
            </thead>
            <tbody id="scs-elim-body"></tbody>
          </table>
        </div>
      </div>
    </section>
  </div>
  </div><!-- /tab-overview -->

  <!-- ====== ROOTING PAGE ====== -->
  <div id="tab-rooting" class="tabpage">
  <section class="card root-card" id="rooting">
    <div class="row">
      <h2>Rooting Guide &amp; IFTTT</h2>
      <span class="chip">Week <span id="root-week"></span></span>
    </div>
    <div class="kpis">
      <div class="kpi"><div class="tiny muted">Group using chalk team</div><div class="n mono" id="kpi-chalk"></div></div>
      <div class="kpi"><div class="tiny muted">Field on chalk</div><div class="n mono" id="kpi-field"></div></div>
      <div class="kpi"><div class="tiny muted">If chalk loses → field out</div><div class="n mono badge-good" id="kpi-chalklose"></div></div>
    </div>
    <div class="rooting-panel" id="rooting-panel">
      <div class="tiny muted">Rooting update loads here.</div>
    </div>
    <h3 style="margin-top:12px">Best Outcomes (Leverage)</h3>
    <table class="root-table" id="root-table">
      <thead><tr>
        <th>Outcome</th><th class="mono">% Field Impact</th><th class="mono">Group Exposure</th><th>Why it helps</th>
      </tr></thead>
      <tbody></tbody>
    </table>
    <div class="ifttt" id="ifttt"></div>
  </section>
  </div><!-- /tab-rooting -->

  <!-- ====== HEDGE PAGE ====== -->
  <div id="tab-hedge" class="tabpage">
  <section class="card" id="hedge">
    <div class="row">
      <h2>Hedge</h2>
      <div class="row-gap">
        <label class="tiny muted">Entry
          <select id="hedgePlayer"></select>
        </label>
        <label class="tiny muted">Week
          <select id="hedgeWeek"></select>
        </label>
        <span class="pill mono" id="hedgeBadges"></span>
      </div>
    </div>

    <div class="hedge-grid" style="margin-top:10px">
      <div class="box">
        <div class="label">Current Pick &amp; History</div>
        <div id="hedgePick" class="stack"></div>
        <div class="note" style="margin-top:6px">
          <strong>Hedge Instructions (American odds only):</strong>
          <ol class="tiny" style="margin:6px 0 0 16px">
            <li>Pick your Entry and Week.</li>
            <li>Opponent moneyline (American) auto-fills — edit if you have a better price.</li>
            <li>Set Entry equity if win (default $1105) and Buy-in (default $1300). Add a Target floor if you want one.</li>
            <li>Click <strong>Equalize Outcomes</strong> (same net both ways), <strong>Hit Target Floor</strong> (guarantee ≥ floor), <strong>Lock Buy-In</strong>, or <strong>Lock $ Profit</strong>.</li>
            <li>Review the table to see hedge net, net after buy-in, and EV.</li>
          </ol>
        </div>
      </div>
      <div class="box">
        <div class="label">Hedge Calculator</div>
        <div class="stack">
          <div class="hc-matchup" id="hcMatchup"></div>
          <div class="tiny muted">Enter opponent <strong>American</strong> moneyline (e.g., +150, -120). No decimals shown.</div>
          <div class="row-gap">
            <label class="tiny muted">Opp. ML (American)
              <input id="hcAmer" type="number" step="1" placeholder="+150" />
            </label>
            <label class="tiny muted">Stake ($)
              <input id="hcStake" type="number" min="0" step="1" value="50" />
            </label>
            <label class="tiny muted">Win chance for your pick (%)
              <input id="hcPwin" type="number" min="1" max="99" step="1" value="60" />
            </label>
            <label class="tiny muted">Entry equity if win ($)
              <input id="hcEquity" type="number" min="0" step="1" value="1105" />
            </label>
            <label class="tiny muted">Buy-in ($)
              <input id="hcBuyin" type="number" min="0" step="1" value="1300" />
            </label>
            <label class="tiny muted">Target floor ($)
              <input id="hcFloor" type="number" min="0" step="1" value="150" />
            </label>
            <label class="tiny muted">Desired profit ($)
              <input id="hcProfit" type="number" min="0" step="1" value="200" />
            </label>
          </div>
          <div class="actions">
            <button id="btnEqualize" class="btn btn-primary" type="button" title="Set stake so both outcomes end equal">Equalize Outcomes</button>
            <button id="btnTarget" class="btn btn-secondary" type="button" title="Minimum stake to guarantee your target floor">Hit Target Floor</button>
            <button id="btnLock" class="btn btn-secondary" type="button" title="Guarantee at least your $1,300 buy-in">Lock Buy-In ($1,300)</button>
            <button id="btnProfit" class="btn btn-secondary" type="button" title="Guarantee buy-in plus desired profit">Lock $ Profit</button>
            <span id="hcWarn" class="note"></span>
          </div>

          <div id="hcExplain" class="explain">
            <div class="headline">Your hedge plan</div>
            <div id="hcSummary"></div>
            <div id="hcWhy" class="callout tiny"></div>
            <div class="sub">Tip: adjust Stake, Target floor, or click a button above to auto-calc a stake.</div>
          </div>
          <table class="root-table" id="hcTable">
            <thead><tr><th>Scenario</th><th class="mono">Net from hedge</th><th class="mono">Net after buy-in</th><th class="mono">EV (given %)</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="chi-card">
      <div class="label">Chicago Specials</div>
      <div class="tiny muted">Pick your South Side flavor — snark up top, formulas behind the curtain.</div>
      <div class="chi-grid" style="margin-top:8px">
        <label>Mode
          <select id="hedgeMode">
            <option value="CHIRAQI">Chiraqi Dome — Full ML hedge; every dollar backs the opponent.</option>
            <option value="SOLDIER">Soldier Cover — 50/50 split between opponent ML and spread.</option>
            <option value="OBLOCK">O-Block Lock — 75/25 ML-heavy blend for steadier protection.</option>
            <option value="CCC">Capone Cover Collector — 25/75 spread-heavy mix to cash on covers.</option>
          </select>
        </label>
        <label>Opponent ML (American)
          <input id="oppML" type="number" step="1" value="-120" />
        </label>
        <label>Spread price (American)
          <input id="spreadPrice" type="number" step="1" value="-110" />
        </label>
        <label>Entry fee ($)
          <input id="entryFee" type="number" min="0" step="1" value="1300" />
        </label>
        <label>Recouped so far ($)
          <input id="recoupedSoFar" type="number" min="0" step="1" value="0" />
        </label>
      </div>
      <div class="chi-note" id="hedgeModeNote"></div>
      <div id="hedgeGrid"></div>
    </div>

    <div class="chi-card">
      <div class="label">Industry Standards</div>
      <div class="tiny muted">The classics everyone talks about in forums.</div>
      <div class="chi-grid" style="margin-top:8px">
        <label>Mode
          <select id="hedgeIndustryMode">
            <option value="ENTRYFEE">Entry Fee Recovery — (Hedge just enough so if you bust, you get your buy-in back)</option>
            <option value="FLAT">Flat Target — (Always hedge to the same fixed KO payout)</option>
            <option value="KELLY">Kelly Criterion — (Mathematical stake sizing by edge & odds)</option>
          </select>
        </label>
      </div>
      <div class="chi-note" id="hedgeIndustryNote"></div>
      <div id="hedgeIndustryGrid"></div>
    </div>
  </section>

  </div><!-- /tab-hedge -->

  <footer>© <span id="year"></span> DeadlineNoon — Survivor</footer>
</div>

<script>
/* ===== Logos & Teams ===== */
const ESPN = {"ARI":"ari","ATL":"atl","BAL":"bal","BUF":"buf","CAR":"car","CHI":"chi","CIN":"cin","CLE":"cle","DAL":"dal","DEN":"den","DET":"det","GB":"gb","HOU":"hou","IND":"ind","JAX":"jac","KC":"kc","LV":"lv","LAC":"lac","LAR":"lar","MIA":"mia","MIN":"min","NE":"ne","NO":"no","NYG":"nyg","NYJ":"nyj","PHI":"phi","PIT":"pit","SEA":"sea","SF":"sf","TB":"tb","TEN":"ten","WAS":"wsh"};
const TEAM_NAME = {"ARI":"Cardinals","ATL":"Falcons","BAL":"Ravens","BUF":"Bills","CAR":"Panthers","CHI":"Bears","CIN":"Bengals","CLE":"Browns","DAL":"Cowboys","DEN":"Broncos","DET":"Lions","GB":"Packers","HOU":"Texans","IND":"Colts","JAX":"Jaguars","KC":"Chiefs","LV":"Raiders","LAC":"Chargers","LAR":"Rams","MIA":"Dolphins","MIN":"Vikings","NE":"Patriots","NO":"Saints","NYG":"Giants","NYJ":"Jets","PHI":"Eagles","PIT":"Steelers","SEA":"Seahawks","SF":"49ers","TB":"Buccaneers","TEN":"Titans","WAS":"Commanders"};
const NFL = Object.keys(TEAM_NAME);

/* ===== SCS Entries ===== */
const SCS_FORCED_WINS = { 1: "Jaguars", 2: "Lions", 3: "Chiefs" };
const SCS_ENTRIES = [
  { name: "Doigetashirtwiththat", status: "alive" },
  { name: "SLYBIZ", status: "eliminated", eliminatedWeek: 3, specialAvailability: "Eliminated Week 3 (Packers)" }
];

const scsWinBadge = team => `<span class="scs-badge win">WIN · ${team || '—'}</span>`;
const scsElimBadge = () => '<span class="scs-badge elim">X</span>';

function renderSCS(){
  const activeBody = document.getElementById("scs-active-body");
  const elimBody = document.getElementById("scs-elim-body");
  const toggle = document.getElementById("scs-elim-toggle");
  const panel = document.getElementById("scs-elim-panel");
  const btn = document.getElementById("scs-elim-btn");
  const xChip = document.querySelector(".elim-x");
  if(!activeBody || !elimBody || !toggle || !panel || !btn || !xChip) return;

  const active = SCS_ENTRIES.filter(entry => entry.status === "alive");
  const eliminated = SCS_ENTRIES.filter(entry => entry.status === "eliminated");

  activeBody.innerHTML = "";
  elimBody.innerHTML = "";

  active.forEach(entry => {
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${entry.name}</td>
      <td>${scsWinBadge(SCS_FORCED_WINS[1])}</td>
      <td>${scsWinBadge(SCS_FORCED_WINS[2])}</td>
      <td>${scsWinBadge(SCS_FORCED_WINS[3])}</td>
      <td class="status-ok">Alive</td>
    `;
    activeBody.appendChild(row);
  });

  toggle.hidden = eliminated.length === 0;

  eliminated.forEach(entry => {
    const row = document.createElement("tr");
    row.classList.add("row-elim");
    const badges = [1, 2, 3].map(week => {
      if(entry.eliminatedWeek === week) return scsElimBadge();
      return scsWinBadge(SCS_FORCED_WINS[week]);
    });
    row.innerHTML = `
      <td><span class="struck">${entry.name}</span></td>
      <td>${badges[0]}</td>
      <td>${badges[1]}</td>
      <td>${badges[2]}</td>
      <td class="status-elim">Eliminated</td>
      <td>${entry.specialAvailability ? entry.specialAvailability : ""}</td>
    `;
    elimBody.appendChild(row);
  });

  const togglePanel = forceOpen => {
    const open = forceOpen !== undefined ? forceOpen : panel.hidden;
    panel.hidden = !open;
    btn.setAttribute("aria-expanded", String(open));
    const plus = btn.querySelector(".elim-plus");
    if(plus) plus.textContent = open ? "–" : "+";
  };

  panel.hidden = true;
  btn.setAttribute("aria-expanded", "false");
  const plus = btn.querySelector(".elim-plus");
  if(plus) plus.textContent = "+";

  btn.onclick = () => togglePanel();
  xChip.onclick = () => togglePanel(true);
}
const logo = c => `https://a.espncdn.com/i/teamlogos/nfl/500/${ESPN[c]}.png`;

/* ===== Broadcast Metadata ===== */
const networkBadgeDataUri = (label, { bg = '#111827', color = '#ffffff', radius = 6 } = {}) => {
  const w = 28;
  const h = 20;
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>`
    + `<rect width='${w}' height='${h}' rx='${radius}' fill='${bg}'/>`
    + `<text x='50%' y='58%' fill='${color}' font-family='"Inter", "Segoe UI", sans-serif' font-size='10' font-weight='700' text-anchor='middle' dominant-baseline='middle'>${label}</text>`
    + '</svg>';
  return `data:image/svg+xml,${encodeURIComponent(svg)}`;
};
const NETWORK_LOGO = {
  ABC: networkBadgeDataUri('ABC', { bg: '#111111' }),
  CBS: networkBadgeDataUri('CBS', { bg: '#0c1a3c' }),
  FOX: networkBadgeDataUri('FOX', { bg: '#0b2240' }),
  NBC: networkBadgeDataUri('NBC', { bg: '#111827' }),
  ESPN: networkBadgeDataUri('ESPN', { bg: '#b91c1c' }),
  NFLN: networkBadgeDataUri('NFLN', { bg: '#1d4ed8' }),
  PRIME: networkBadgeDataUri('PRIME', { bg: '#0a192f' })
};

function resolveNetwork(gameObj){
  if(gameObj?.network && NETWORK_LOGO[gameObj.network.toUpperCase()]){
    return gameObj.network.toUpperCase();
  }
  const slot = gameObj?.slot ? String(gameObj.slot).toUpperCase() : "";
  if(slot === 'TNF') return 'PRIME';
  if(slot === 'SNF') return 'NBC';
  if(slot === 'MNF') return 'ESPN';

  if(gameObj?.kickoff){
    const d = new Date(gameObj.kickoff);
    if(Number.isFinite(d.getTime())){
      const dow = d.getUTCDay();
      const hour = d.getUTCHours();
      if(dow === 4) return 'PRIME';
      if(dow === 0 && hour >= 22) return 'NBC';
      if(dow === 1) return 'ESPN';
    }
  }
  return 'FOX';
}

function isThanksgiving(date){
  const d = new Date(date);
  if(!Number.isFinite(d.getTime())) return false;
  if(d.getUTCMonth() !== 10) return false;
  const first = new Date(Date.UTC(d.getUTCFullYear(), 10, 1));
  const firstThuOffset = (4 - first.getUTCDay() + 7) % 7;
  const thanksgiving = new Date(Date.UTC(d.getUTCFullYear(), 10, 1 + firstThuOffset + 21));
  return d.getUTCFullYear() === thanksgiving.getUTCFullYear()
    && d.getUTCMonth() === thanksgiving.getUTCMonth()
    && d.getUTCDate() === thanksgiving.getUTCDate();
}

function isThanksgivingEve(date){
  const d = new Date(date);
  if(!Number.isFinite(d.getTime())) return false;
  const prev = new Date(d.getTime() - 24*60*60*1000);
  return isThanksgiving(prev);
}

function isEveningKick(gameObj){
  if(!gameObj) return false;
  const timeStr = String(gameObj.time || '').toLowerCase();
  const match = timeStr.match(/(\d{1,2}):(\d{2})\s*p/);
  if(match){
    const hour = Number(match[1]) % 12;
    return hour >= 6;
  }
  if(gameObj.kickoff){
    const dt = new Date(gameObj.kickoff);
    if(Number.isFinite(dt.getTime())){
      const hour = dt.getUTCHours();
      return hour < 3;
    }
  }
  return false;
}

function resolveHolidayBadge(gameObj){
  const tag = String(gameObj?.tag || '').toUpperCase();
  if(tag === 'BF') return {kind:'black-friday', text:'Black Friday'};
  if(tag === 'XMAS') return {kind:'christmas', text:'Christmas'};
  if(tag === 'TG'){
    const evening = isEveningKick(gameObj);
    return evening
      ? {kind:'thanksgiving-night', text:'Thanksgiving Night'}
      : {kind:'thanksgiving', text:'Thanksgiving'};
  }
  if(!gameObj?.kickoff) return null;
  const dt = new Date(gameObj.kickoff);
  if(isThanksgiving(dt)) return {kind:'thanksgiving', text:'Thanksgiving'};
  if(isThanksgivingEve(dt)) return {kind:'thanksgiving-night', text:'Thanksgiving Night'};
  if(dt.getUTCDay() === 4) return {kind:'tnf', text:'TNF'};
  const slot = gameObj?.slot ? String(gameObj.slot).toUpperCase() : "";
  if(slot === 'TNF') return {kind:'tnf', text:'TNF'};
  return null;
}

function networkMetaHtml(gameObj){
  if(!gameObj) return '';
  const net = resolveNetwork(gameObj);
  const badge = resolveHolidayBadge(gameObj);
  const logoHtml = NETWORK_LOGO[net]
    ? `<img class="net-logo" alt="${net}" src="${NETWORK_LOGO[net]}">`
    : `<span class="net-badge">${net}</span>`;

  let badgeHtml = '';
  if(badge){
    if(badge.kind === 'thanksgiving'){
      badgeHtml = `<span class="net-badge thanksgiving"><span aria-hidden="true">🦃</span> ${badge.text}</span>`;
    }else if(badge.kind === 'thanksgiving-night'){
      badgeHtml = `<span class="net-badge thanksgiving" title="${badge.text}" aria-label="${badge.text}"><span aria-hidden="true">🦃 PM</span></span>`;
    }else if(badge.kind === 'christmas'){
      badgeHtml = `<span class="net-badge christmas"><span aria-hidden="true">🎄</span> ${badge.text}</span>`;
    }else if(badge.kind === 'black-friday'){
      badgeHtml = `<span class="net-badge black-friday"><span aria-hidden="true">🛍</span> ${badge.text}</span>`;
    }else{
      badgeHtml = `<span class="net-badge tnf">${badge.text}</span>`;
    }
  }

  return `<div class="game-meta">${logoHtml}${badgeHtml}</div>`;
}

function renderNetworkMeta(containerEl, gameObj){
  if(!containerEl) return;
  const html = networkMetaHtml(gameObj);
  if(!html) return;
  containerEl.querySelector('.game-meta')?.remove();
  const frag = document.createElement('div');
  frag.innerHTML = html;
  const node = frag.firstElementChild;
  if(node) containerEl.appendChild(node);
}

/* ===== Special Weeks ===== */
const TG_BF = ["GB","DET","KC","DAL","CIN","BAL","CHI","PHI"]; // 8
const XMAS  = ["DAL","WAS","DET","MIN","DEN","KC"];            // 6
const SPECIAL_THRESHOLD = 0.40;
const TG_THRESHOLD = Math.ceil(TG_BF.length * SPECIAL_THRESHOLD);   // 4
const XMAS_THRESHOLD = Math.ceil(XMAS.length  * SPECIAL_THRESHOLD); // 3
const SPECIAL_GAME_GROUPS = [
  {
    key:"TG_BF",
    title:"Thanksgiving & Black Friday Slate",
    games:[
      {tag:"TG", date:"Thu • Nov 27", time:"12:30p ET", away:"GB", home:"DET"},
      {tag:"TG", date:"Thu • Nov 27", time:"4:30p ET", away:"KC", home:"DAL"},
      {tag:"TG", date:"Thu • Nov 27", time:"8:20p ET", away:"CIN", home:"BAL"},
      {tag:"BF", date:"Fri • Nov 28", time:"3:00p ET", away:"CHI", home:"PHI"}
    ]
  },
  {
    key:"XMAS",
    title:"Christmas Slate",
    games:[
      {tag:"XMAS", date:"Thu • Dec 25", time:"1:00p ET", away:"MIN", home:"DET"},
      {tag:"XMAS", date:"Thu • Dec 25", time:"4:30p ET", away:"WAS", home:"DAL"},
      {tag:"XMAS", date:"Thu • Dec 25", time:"8:15p ET", away:"DEN", home:"KC"}
    ]
  }
];
const TG_MATCHUP_TAG = {
  GB:"GB@DET",
  DET:"GB@DET",
  KC:"KC@DAL",
  DAL:"KC@DAL",
  CIN:"CIN@BAL",
  BAL:"CIN@BAL",
  CHI:"CHI@PHI",
  PHI:"CHI@PHI"
};
const XMAS_MATCHUP_TAG = {
  DAL:"WAS@DAL",
  WAS:"WAS@DAL",
  DET:"MIN@DET",
  MIN:"MIN@DET",
  DEN:"DEN@KC",
  KC:"DEN@KC"
};

const CONTEST_NAME = 'SuperContest Survivor';
const INITIAL_ENTRIES = 111;
const BUY_IN = 5000;
const TOTAL_PRIZE_POOL = INITIAL_ENTRIES * BUY_IN; // $5,000 winner-take-all buy-in
const CURRENT_LIVE_ENTRIES = 91; // updated after Week 3 results
const ENTRIES_ON_CHALK_TONIGHT = 0;

const USD0 = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  maximumFractionDigits: 0,
});

function fmtUSD(value){
  return USD0.format(value);
}

function impliedValueContext(){
  const alive = Math.max(1, CURRENT_LIVE_ENTRIES);
  const survivorsIfLose = Math.max(1, CURRENT_LIVE_ENTRIES - ENTRIES_ON_CHALK_TONIGHT);
  const impliedNow = TOTAL_PRIZE_POOL / alive;
  const impliedIfLose = TOTAL_PRIZE_POOL / survivorsIfLose;
  const delta = impliedIfLose - impliedNow;
  return { impliedNow, impliedIfLose, delta, survivorsIfLose };
}


/* ===== Seeded Data (W1–W3) ===== */
/* Results: W=win, L=loss, T=tie, P=pending */
const STARTER = {
  meta: {
    season: 2025,
    currentWeek: 4,
    weekDates: {
      "1":"2025-09-07","2":"2025-09-14","3":"2025-09-21",
      "4":"2025-09-28","5":"2025-10-05","6":"2025-10-12","7":"2025-10-19","8":"2025-10-26",
      "9":"2025-11-02","10":"2025-11-09","11":"2025-11-16","12":"2025-11-23",
      "13":"2025-11-30","14":"2025-12-07","15":"2025-12-14",
      "16":"2025-12-28","17":"2026-01-04"
    }
  },
  players: [
    { name: "Doigetashirtwiththat" }
  ],
  picks: [
    { week: 1, player: "Doigetashirtwiththat", team: "JAX", result: "W" },
    { week: 2, player: "Doigetashirtwiththat", team: "DET", result: "W" },
    { week: 3, player: "Doigetashirtwiththat", team: "KC",  result: "W" }
  ]
};

/* ===== Persistence ===== */
const LS_KEY = "deadlineNoon_survivor_v5";
function loadData(){ try{ const raw=localStorage.getItem(LS_KEY); if(raw) return JSON.parse(raw);}catch(e){} return STARTER; }
function saveData(d){ localStorage.setItem(LS_KEY, JSON.stringify(d)); }

/* ===== Utils ===== */
const uniq = a => Array.from(new Set(a));

function resultInfo(result){
  const value = String(result || '').toUpperCase();
  if(value === 'W') return { symbol:'✓', class:'win', label:'Win' };
  if(value === 'L' || value === 'T') return { symbol:'✗', class:'loss', label: value==='T' ? 'Tie = Loss' : 'Loss' };
  return { symbol:'•', class:'pending', label:'Pending' };
}

function teamNameHtml(team, resultClass){
  const name = TEAM_NAME[team] || team;
  const cls = resultClass === 'loss' ? 'team-name strike' : 'team-name';
  return `<span class="${cls}">${name}</span>`;
}

function resultSymbolHtml(result){
  const info = resultInfo(result);
  const cls = `result-symbol result-${info.class}`;
  return `<span class="${cls}" title="${info.label}">${info.symbol}</span>`;
}

function resultChipHtml(result){
  const info = resultInfo(result);
  if(info.class === 'pending') return `<span class="chip tiny">Pending</span>`;
  const chipClass = info.class === 'win' ? 'chip ok tiny' : 'chip bad tiny';
  return `<span class="${chipClass}">${info.symbol} ${info.label}</span>`;
}

function resultDetailLabel(result){
  const info = resultInfo(result);
  return info.class === 'pending' ? info.label : `${info.symbol} ${info.label}`;
}
const SPECIAL_ICONS = {TG:"🦃", BF:"🛍", XMAS:"🎄"};
const specialIcon = tag => SPECIAL_ICONS[tag] || "";
const weekIsSpecial = w => ["TG","XMAS"].includes(String(w));
const isTG = w => String(w)==="TG"; const isXMAS = w => String(w)==="XMAS";
const wLabel = w => isTG(w)?"Thanksgiving+BF":(isXMAS(w)?"Christmas":"W"+w);
const fmtDate = d => { try{ return new Date(d+"T00:00:00").toLocaleDateString(); }catch{ return d; } };
function weekOrder(){ return Object.keys(state.data.meta.weekDates); }
function cmpWeek(a,b){ const o=weekOrder(); return o.indexOf(String(a)) - o.indexOf(String(b)); }
function usedTeamsBeforeWeek(picks, player, week){ const idx=weekOrder().indexOf(String(week))-1; return uniq(picks.filter(p=>p.player===player && weekOrder().indexOf(String(p.week))<=idx).map(p=>p.team)); }
function usedTeamsUpTo(picks, player, week){ const idx=weekOrder().indexOf(String(week)); return uniq(picks.filter(p=>p.player===player && weekOrder().indexOf(String(p.week))<=idx).map(p=>p.team)); }
function availableForWeek(picks, player, week){ const prior=usedTeamsBeforeWeek(picks, player, week); const pool=isTG(week)?TG_BF:isXMAS(week)?XMAS:NFL; return pool.filter(t=>!prior.includes(t)); }
function entryStatus(picks, player, week){ const up=picks.filter(p=>p.player===player && cmpWeek(p.week, week)<=0).sort((a,b)=>cmpWeek(a.week,b.week)); for(const p of up){ if(p.result==="L") return {eliminated:true, reason:`Loss in ${wLabel(p.week)} (${TEAM_NAME[p.team]})`}; if(p.result==="T") return {eliminated:true, reason:`Tie in ${wLabel(p.week)} (ties = loss)`}; } return {eliminated:false, reason:""}; }
function specialUsage(used){ return {tg:used.filter(t=>TG_BF.includes(t)).length, xm:used.filter(t=>XMAS.includes(t)).length}; }

/* ===== Hedge Week Locking (Tue 12:01 ET unlock) ===== */
const LOCKED_MAX_WEEK = 3;
const UNLOCK_DOW = 2; // Tuesday (0=Sun)
const UNLOCK_HOUR = 0;
const UNLOCK_MIN = 1;

function easternNow(){
  return new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
}

function nextTuesdayAt0001ET(from = easternNow()){
  const d = new Date(from);
  const day = d.getDay();
  let add = (UNLOCK_DOW - day + 7) % 7;
  if(add === 0 && (d.getHours() > UNLOCK_HOUR || (d.getHours() === UNLOCK_HOUR && d.getMinutes() >= UNLOCK_MIN))){
    add = 7;
  }
  d.setDate(d.getDate() + add);
  d.setHours(UNLOCK_HOUR, UNLOCK_MIN, 0, 0);
  return d;
}

function isUnlockedBeyond3(){
  const now = easternNow();
  const unlock = new Date(now);
  const day = unlock.getDay();
  const delta = (UNLOCK_DOW - day + 7) % 7;
  unlock.setDate(unlock.getDate() + delta);
  unlock.setHours(UNLOCK_HOUR, UNLOCK_MIN, 0, 0);
  return now >= unlock;
}

function isWeekLocked(wk){
  const num = Number(wk);
  return Number.isFinite(num) && !isUnlockedBeyond3() && num > LOCKED_MAX_WEEK;
}

function clampWeekValue(wk){
  if(isWeekLocked(wk)){
    return typeof wk === 'string' ? String(LOCKED_MAX_WEEK) : LOCKED_MAX_WEEK;
  }
  return wk;
}

function lockFutureWeeksUI(){
  const weekSel = document.getElementById('hedgeWeek');
  const unlocked = isUnlockedBeyond3();
  if(weekSel){
    Array.from(weekSel.options).forEach(opt=>{
      const wk = Number(opt.value);
      const locked = Number.isFinite(wk) && wk > LOCKED_MAX_WEEK && !unlocked;
      opt.disabled = locked;
      if(locked){
        opt.title = 'Locked until Tue 12:01 AM ET';
        opt.classList.add('is-locked');
      }else{
        opt.title = '';
        opt.classList.remove('is-locked');
      }
    });

    if(!unlocked){
      const cur = Number(weekSel.value);
      if(Number.isFinite(cur) && cur > LOCKED_MAX_WEEK){
        weekSel.value = String(LOCKED_MAX_WEEK);
        if(typeof renderHedge === 'function') renderHedge();
      }
    }

    state.hedgeWeek = weekSel.value;

    let bar = document.getElementById('weekLockBanner');
    if(!bar){
      bar = document.createElement('div');
      bar.id = 'weekLockBanner';
      bar.style.cssText = 'margin:.5rem 0;padding:.5rem .75rem;border-radius:8px;background:#fff4cc;border:1px solid #ffd66b;font:500 13px system-ui;color:#614300;';
      const host = weekSel.closest('.row-gap') || weekSel.parentElement;
      host?.appendChild(bar);
    }

    if(!unlocked){
      const unlockAt = nextTuesdayAt0001ET();
      const fmt = unlockAt.toLocaleString('en-US', { timeZone:'America/New_York', hour:'numeric', minute:'2-digit', weekday:'short', month:'short', day:'numeric' });
      bar.textContent = `Weeks ${LOCKED_MAX_WEEK+1}+ unlock Tue 12:01 AM ET (${fmt}).`;
      bar.style.display = '';
    }else{
      bar.style.display = 'none';
    }
  }

  if(typeof window.updatePickLockState === 'function'){
    window.updatePickLockState();
  }
}

function setWeekSafely(wk){
  const weekSel = document.getElementById('hedgeWeek');
  const clamped = clampWeekValue(Number(wk));
  if(weekSel) weekSel.value = String(clamped);
  if(typeof renderHedge === 'function') renderHedge();
}

/* ===== Alerts ===== */
const notifyThreshold = () => {};
function thresholdAlerts(){
  const w = state.data.meta.currentWeek;
  for(const pl of state.data.players){
    const used = usedTeamsUpTo(state.data.picks, pl.name, w);
    const {tg, xm} = specialUsage(used);
    const key = s => `dn_thr_${pl.name}_${w}_${s}`;
    if(tg === TG_THRESHOLD-1 && !sessionStorage.getItem(key("tg_about"))){ notifyThreshold(`Heads up: ${pl.name} is about to pass 40% TG usage (${tg}/${TG_BF.length}).`); sessionStorage.setItem(key("tg_about"),"1"); }
    if(tg >= TG_THRESHOLD   && !sessionStorage.getItem(key("tg_pass")) ){ notifyThreshold(`Notice: ${pl.name} is ≥40% on TG usage (${tg}/${TG_BF.length}).`); sessionStorage.setItem(key("tg_pass"),"1"); }
    if(xm === XMAS_THRESHOLD-1 && !sessionStorage.getItem(key("xm_about"))){ notifyThreshold(`Heads up: ${pl.name} is about to pass 40% XMAS usage (${xm}/${XMAS.length}).`); sessionStorage.setItem(key("xm_about"),"1"); }
    if(xm >= XMAS_THRESHOLD    && !sessionStorage.getItem(key("xm_pass")) ){ notifyThreshold(`Notice: ${pl.name} is ≥40% on XMAS usage (${xm}/${XMAS.length}).`); sessionStorage.setItem(key("xm_pass"),"1"); }
  }
}

/* ===== UI Render ===== */
window.state = window.state || { data: loadData() };
const state = window.state;
if(!state.specialFocus && state.data.players.length){ state.specialFocus = state.data.players[0].name; }
if(!state.hedgePlayer && state.data.players.length){ state.hedgePlayer = state.data.players[0].name; }
if(!state.hedgeWeek){ state.hedgeWeek = String(state.data.meta.currentWeek); }
if(!state.trackerDensity){ state.trackerDensity = "compact"; }
function cellLogo(code,big=false){ return `<img class="${big?'logo-lg':'logo'}" alt="${TEAM_NAME[code]}" src="${logo(code)}">`; }

/* ===== Lines Storage (American ML) ===== */
const LS_LINES = "dn_lines_v1";
const LINES_DEFAULT = {
  "3": {
    "IND@TEN": { home: "TEN", away: "IND", ml: { "IND": 140, "TEN": -165 } },
    "PIT@NE":  { home: "NE",  away: "PIT", ml: { "PIT": -123, "NE": 104 } },
    "NYJ@TB":  { home: "TB",  away: "NYJ", ml: { "NYJ": 256, "TB": -325 } },
    "LV@WAS":  { home: "WAS", away: "LV",  ml: { "LV": 130, "WAS": -152 } },
    "LAR@PHI": { home: "PHI", away: "LAR", ml: { "LAR": 161, "PHI": -182 } },
    "ATL@CAR": { home: "CAR", away: "ATL", ml: { "ATL": -232, "CAR": 188 } },
    "CIN@MIN": { home: "MIN", away: "CIN", ml: { "CIN": 134, "MIN": -161 } },
    "HOU@JAX": { home: "JAX", away: "HOU", ml: { "HOU": 114, "JAX": -126 } },
    "GB@CLE":  { home: "CLE", away: "GB",  ml: { "GB": -458, "CLE": 366 } },
    "DEN@LAC": { home: "LAC", away: "DEN", ml: { "DEN": 130, "LAC": -154 } },
    "NO@SEA":  { home: "SEA", away: "NO",  ml: { "NO": 296, "SEA": -362 } },
    "ARI@SF":  { home: "SF",  away: "ARI", ml: { "ARI": 116, "SF": -133 } },
    "DAL@CHI": { home: "CHI", away: "DAL", ml: { "DAL": -121, "CHI": 105 } },
    "KC@NYG":  { home: "NYG", away: "KC",  ml: { "KC": -308, "NYG": 244 } },
    "DET@BAL": { home: "BAL", away: "DET", ml: { "DET": 198, "BAL": -232 } }
  }
};
const WEEK3_FIX = {
  "IND@TEN": { home: "TEN", away: "IND" },
  "PIT@NE":  { home: "NE",  away: "PIT" },
  "NYJ@TB":  { home: "TB",  away: "NYJ" },
  "LV@WAS":  { home: "WAS", away: "LV" },
  "LAR@PHI": { home: "PHI", away: "LAR" },
  "ATL@CAR": { home: "CAR", away: "ATL" },
  "CIN@MIN": { home: "MIN", away: "CIN" },
  "HOU@JAX": { home: "JAX", away: "HOU" },
  "GB@CLE":  { home: "CLE", away: "GB" },
  "DEN@LAC": { home: "LAC", away: "DEN" },
  "NO@SEA":  { home: "SEA", away: "NO" },
  "ARI@SF":  { home: "SF",  away: "ARI" },
  "DAL@CHI": { home: "CHI", away: "DAL" },
  "KC@NYG":  { home: "NYG", away: "KC" },
  "DET@BAL": { home: "BAL", away: "DET" }
};
function getTeamsFor(gameId, weekNumber){
  if(String(weekNumber)==="3" && WEEK3_FIX[gameId]){
    return { ...WEEK3_FIX[gameId] };
  }
  const defaultsForWeek = LINES_DEFAULT[String(weekNumber)]?.[gameId];
  if(defaultsForWeek){
    return { home: defaultsForWeek.home, away: defaultsForWeek.away };
  }
  const parts = gameId ? gameId.split("@") : [];
  if(parts.length === 2){
    const [away, home] = parts;
    return { home, away };
  }
  return { home: "", away: "" };
}
const cloneDeep = obj => JSON.parse(JSON.stringify(obj));
function needsWeekRefresh(lines, week){
  const defaults = LINES_DEFAULT[week];
  if(!defaults) return false;
  const stored = lines && lines[week];
  if(!stored) return true;
  return Object.keys(defaults).some(matchId=>{
    const expected = getTeamsFor(matchId, week);
    const game = stored[matchId];
    if(!game) return true;
    return game.home !== expected.home || game.away !== expected.away;
  });
}
function refreshWeek(lines, week){
  const defaults = LINES_DEFAULT[week];
  if(!defaults) return lines;
  const base = cloneDeep(lines || {});
  base[week] = {};
  Object.entries(defaults).forEach(([matchId, defGame])=>{
    const storedGame = lines && lines[week] && lines[week][matchId];
    const merged = cloneDeep(defGame);
    const teams = getTeamsFor(matchId, week);
    merged.home = teams.home;
    merged.away = teams.away;
    if(storedGame && storedGame.home === teams.home && storedGame.away === teams.away && storedGame.ml){
      merged.ml = Object.assign({}, merged.ml || {}, storedGame.ml);
    }
    base[week][matchId] = merged;
  });
  return base;
}
function loadLines(){
  try{
    const raw = localStorage.getItem(LS_LINES);
    if(raw){
      const parsed = JSON.parse(raw);
      if(needsWeekRefresh(parsed, "3")){
        const updated = refreshWeek(parsed, "3");
        saveLines(updated);
        return updated;
      }
      return parsed;
    }
  }catch{}
  return cloneDeep(LINES_DEFAULT);
}
function saveLines(obj){ localStorage.setItem(LS_LINES, JSON.stringify(obj)); }
let NFL_LINES = loadLines();
function findOpponentInfo(week, myTeam){
  const matchups = NFL_LINES[String(week)] || {};
  for(const key of Object.keys(matchups)){
    const teams = getTeamsFor(key, week);
    const game = matchups[key] || {};
    const mlBook = game.ml || {};
    if(teams.home === myTeam){
      return { team: teams.away, ml: mlBook?.[teams.away] ?? null };
    }
    if(teams.away === myTeam){
      return { team: teams.home, ml: mlBook?.[teams.home] ?? null };
    }
  }
  return null;
}
function getOpponentML(week, myTeam){
  const info = findOpponentInfo(week, myTeam);
  return info ? info.ml : null;
}
const fmtML = ml => ml>0?`+${ml}`:String(ml);

function updateImpliedCard(){
  const { impliedNow } = impliedValueContext();
  const card = document.getElementById("prize-pool");
  if(!card) return;
  const label = card.querySelector('.label') || card;
  const value = card.querySelector('.value') || card;
  if(label) label.textContent = 'Implied Value (per entry)';
  if(value) value.textContent = fmtUSD(impliedNow);
  const note = card.querySelector('.note');
  if(note){
    note.innerHTML = `Live entries: <span id="live-entries">${CURRENT_LIVE_ENTRIES.toLocaleString()}</span> • Buy-in ${fmtUSD(BUY_IN)}`;
  }
}

function renderRootingCallout(impliedNow, impliedIfLose, delta){
  const panel = document.getElementById('rooting-panel');
  if(!panel) return;
  const liveText = `${CURRENT_LIVE_ENTRIES.toLocaleString()} of ${INITIAL_ENTRIES.toLocaleString()} entries remain`;
  const impliedNowRounded = fmtUSD(Math.round(impliedNow));
  const prizeText = `${fmtUSD(TOTAL_PRIZE_POOL)} winner-take-all`; 
  const buyInText = fmtUSD(BUY_IN);

  let exposureHtml = `<div class="rooting-note">${liveText}. No in-progress exposure tonight.</div>`;

  if(ENTRIES_ON_CHALK_TONIGHT > 0){
    const impliedIfLoseRounded = fmtUSD(Math.round(impliedIfLose));
    const deltaRounded = Math.round(delta);
    const deltaPrefix = deltaRounded >= 0 ? '+' : '-';
    const deltaLabel = `${deltaPrefix}${fmtUSD(Math.abs(deltaRounded))}`;
    const entriesText = ENTRIES_ON_CHALK_TONIGHT.toLocaleString();
    exposureHtml = `
      <div class="rooting-note">${entriesText} entries still active tonight; if they bust, remaining entries drop to ${(CURRENT_LIVE_ENTRIES - ENTRIES_ON_CHALK_TONIGHT).toLocaleString()}.</div>
      <div class="rooting-action">Implied value would move to <strong>${impliedIfLoseRounded}</strong> (${deltaLabel}).</div>
    `;
  }

  panel.innerHTML = `
    <div class="rooting-title">Rooting • ${CONTEST_NAME}</div>
    <div class="rooting-game">${prizeText} • ${buyInText} buy-in</div>
    <div class="rooting-action">Implied value now sits at <strong>${impliedNowRounded}</strong>.</div>
    ${exposureHtml}
  `;
}

function renderHeader(){
  const w = state.data.meta.currentWeek;
  document.getElementById("hdr-week").textContent = wLabel(w);
  document.getElementById("hdr-date").textContent = fmtDate(state.data.meta.weekDates[String(w)]);
  document.getElementById("year").textContent = new Date().getFullYear();
  document.getElementById("weekType").textContent = isTG(w)?"Special: Thanksgiving+BF":isXMAS(w)?"Special: Christmas":"Regular Week";
  const badgeEl = document.getElementById("env-badge");
  if(badgeEl){
    const host = location.hostname;
    const isLocal = host==="localhost" || host.startsWith("127.");
    badgeEl.style.display = "inline-flex";
    badgeEl.textContent = isLocal ? "localhost preview" : "DONE ✅";
  }
  const impliedBanner = document.getElementById("impliedBanner");
  if(impliedBanner){
    const liveText = CURRENT_LIVE_ENTRIES.toLocaleString();
    const potText = fmtUSD(TOTAL_PRIZE_POOL);
    const startText = INITIAL_ENTRIES.toLocaleString();
    const buyInText = fmtUSD(BUY_IN);
    impliedBanner.textContent = `▌ ${liveText} entries alive • ${potText} winner-take-all • buy-in ${buyInText} • started with ${startText} entries`;
  }
  updateImpliedCard();
}

function setSpecialFocus(name){
  if(!name) return false;
  if(!state.data.players.some(p=>p.name===name)) return false;
  const changed = state.specialFocus !== name;
  state.specialFocus = name;
  return changed;
}

function renderSpecialGames(){
  const wrap = document.getElementById("specialGameCards");
  if(!wrap) return;
  if(!SPECIAL_GAME_GROUPS.length){
    wrap.innerHTML = '<div class="tiny muted">No special slates for this contest.';
    return;
  }
  if(!state.data.players.length){ wrap.innerHTML = ""; return; }
  if(!state.specialFocus || !state.data.players.some(p=>p.name===state.specialFocus)){
    state.specialFocus = state.data.players[0].name;
  }
  const focus = state.specialFocus;
  const used = new Set(usedTeamsUpTo(state.data.picks, focus, state.data.meta.currentWeek));

  const groups = SPECIAL_GAME_GROUPS.map(group=>{
    const cards = group.games.map(game=>{
      const awayUsed = used.has(game.away);
      const homeUsed = used.has(game.home);
      const meta = networkMetaHtml(game);
      return `
        <div class="game-card">
          <div class="game-header">
            <span class="game-icon">${specialIcon(game.tag)}</span>
            <div>
              <div>${game.date}</div>
              <div>${game.time}</div>
            </div>
          </div>
          ${meta}
          <div class="game-body">
            <div class="game-team${awayUsed?" used":""}">${cellLogo(game.away,true)}${TEAM_NAME[game.away]}</div>
            <div class="game-at">at</div>
            <div class="game-team${homeUsed?" used":""}">${cellLogo(game.home,true)}${TEAM_NAME[game.home]}</div>
          </div>
        </div>
      `;
    }).join("");
    return `
      <div class="special-games-group">
        <div class="tiny muted" style="text-transform:uppercase;letter-spacing:.5px;">${group.title}</div>
        <div class="special-games-row">${cards}</div>
      </div>
    `;
  }).join("");

  wrap.innerHTML = `${groups}<div class="special-focus-note">Viewing availability for <strong>${focus}</strong>.</div>`;
}

function bindSpecialStatusFocus(){
  const table = document.getElementById("specialStatus");
  if(!table || table.dataset.focusBound) return;
  table.dataset.focusBound = "1";
  table.addEventListener("click", event=>{
    const control = event.target.closest(".toggle-btn, .open-panel");
    if(!control) return;
    event.preventDefault();
    const panelId = control.getAttribute("data-target") || control.getAttribute("aria-controls");
    if(!panelId) return;
    const panel = document.getElementById(panelId);
    if(!panel) return;
    const willOpen = !panel.classList.contains("open");
    panel.classList.toggle("open", willOpen);
    const player = control.dataset.player || panel.dataset.player;
    table.querySelectorAll(`[data-target="${panelId}"], [aria-controls="${panelId}"]`).forEach(btn=>{
      btn.setAttribute("aria-expanded", String(willOpen));
      if(btn.classList.contains("toggle-btn")){
        btn.innerHTML = specialPanelLabel(willOpen);
      }
      if(btn.classList.contains("open-panel")){
        btn.textContent = willOpen ? "Hide teams" : "View teams";
      }
    });
    if(player){
      const key = `open_avail_${player}`;
      if(willOpen){
        sessionStorage.setItem(key, "1");
      }else{
        sessionStorage.removeItem(key);
      }
    }
    if(willOpen){
      if(player && setSpecialFocus(player)){
        renderSpecialGames();
      }
    }
  });
}

function renderTracker(){
  const tbody = document.querySelector("#tracker tbody"); if(!tbody) return; tbody.innerHTML = "";
  const week = state.data.meta.currentWeek;
  let active = 0;

  state.data.players.forEach(pl=>{
    const picksForPlayer = state.data.picks.filter(p=>p.player===pl.name).sort((a,b)=>cmpWeek(a.week,b.week));
    const usedList = picksForPlayer.map(p=>({
      w: p.week,
      t: p.team,
      r: String(p.result || 'P').toUpperCase()
    }));

    const status = entryStatus(state.data.picks, pl.name, week);
    const avail  = availableForWeek(state.data.picks, pl.name, week);

    const usedUp = usedTeamsUpTo(state.data.picks, pl.name, week);
    const {tg, xm} = specialUsage(usedUp);
    const flags = [];
    if(tg === TG_THRESHOLD-1) flags.push(`<span class="chip warn tiny">about to 40% (TG)</span>`);
    if(tg >= TG_THRESHOLD)    flags.push(`<span class="chip info tiny">≥40% (TG)</span>`);
    if(xm === XMAS_THRESHOLD-1) flags.push(`<span class="chip warn tiny">about to 40% (XMAS)</span>`);
    if(xm >= XMAS_THRESHOLD)    flags.push(`<span class="chip info tiny">≥40% (XMAS)</span>`);

    let specialRisk = "";
    if(isTG(week) && avail.length===0) specialRisk = `<span class="chip bad tiny">No TG team left</span>`;
    if(isXMAS(week) && avail.length===0) specialRisk = `<span class="chip bad tiny">No XMAS team left</span>`;

    if(!status.eliminated) active++;

    const mini = usedList.length
      ? usedList.map(p=>{
          const info = resultInfo(p.r);
          const teamLabel = teamNameHtml(p.t, info.class);
          const tail = info.class==='pending'
            ? `<span class="muted tiny">(${info.label})</span>`
            : resultSymbolHtml(p.r);
          return `<span class="u-chip"><span class="wk">${wLabel(p.w)}</span>${cellLogo(p.t)} ${teamLabel} ${tail}</span>`;
        }).join("")
      : "<span class='muted'>—</span>";

    const availChips = status.eliminated
      ? "<span class='muted tiny'>—</span>"
      : (avail.length? avail.map(c=>`<span class="chip">${cellLogo(c)}${TEAM_NAME[c]}</span>`).join("") : "<span class='muted tiny'>—</span>");

    const usedDetail = usedList.length
      ? usedList.map(p=>{
          const info = resultInfo(p.r);
          const teamLabel = teamNameHtml(p.t, info.class);
          const detail = `${wLabel(p.w)} • ${resultDetailLabel(p.r)}`;
          return `<span class="chip dim">${cellLogo(p.t)} ${teamLabel} <span class="muted">(${detail})</span></span>`;
        }).join("")
      : "<span class='muted tiny'>—</span>";

    const tr = document.createElement("tr");
    const panelId = `trk-${cssSafe(pl.name)}`;
    tr.innerHTML = `
      <td>
        <div class="rowline">
          <div>
            <strong>${pl.name}</strong>
            ${status.eliminated?`<span class="chip bad tiny">ELIMINATED</span>`:`<span class="chip ok tiny">ACTIVE</span>`}
            ${flags.join(" ")} ${specialRisk}
          </div>
          <div class="right-meta">
            <span class="mutey">Avail: ${status.eliminated?0:avail.length}</span>
            <button class="toggle-btn" data-player="${htmlSafe(pl.name)}" aria-expanded="false" aria-controls="${panelId}"><span class="chev">▸</span> Show</button>
          </div>
        </div>
        <div class="used-mini" style="margin-top:6px">${mini}</div>
        <div class="trk-panel" id="${panelId}">
          <div class="trk-grid">
            <div class="trk-col">
              <h4>Available Now</h4>
              <div class="chips">${availChips}</div>
            </div>
            <div class="trk-col">
              <h4>All Used (detail)</h4>
              <div class="chips">${usedDetail}</div>
            </div>
          </div>
        </div>
      </td>
      <td class="mono" style="text-align:right">${status.eliminated?"—":`${avail.length} avail`}</td>
    `;
    tbody.appendChild(tr);
  });

  document.getElementById("activeCount").textContent = `${active} active / ${state.data.players.length}`;
  const activeHeadline = document.getElementById("activeHeadline");
  if(activeHeadline){
    const total = state.data.players.length || 0;
    activeHeadline.innerHTML = `
      <span class="count">${active}</span>
      <span class="slash">/</span>
      <span class="total">${total}</span>
      <span class="label">alive</span>
    `;
  }

  tbody.querySelectorAll(".toggle-btn").forEach(btn=>{
    btn.addEventListener("click",()=>{
      const id = btn.getAttribute("aria-controls");
      const panel = document.getElementById(id);
      if(!panel) return;
      const open = btn.getAttribute("aria-expanded")==="true";
      btn.setAttribute("aria-expanded", String(!open));
      panel.classList.toggle("open", !open);
      btn.innerHTML = `<span class="chev">▸</span> ${!open?"Hide":"Show"}`;
    });
  });

  const dens = document.getElementById("trkDensity");
  const table = document.getElementById("tracker");
  if(dens && table){
    dens.value = state.trackerDensity || "compact";
    table.classList.toggle("trk-compact", dens.value!=="comfort");
    dens.onchange = ()=>{
      state.trackerDensity = dens.value;
      table.classList.toggle("trk-compact", dens.value!=="comfort");
    };
  }
}

function renderSpecialStatus(){
  const table = document.getElementById("specialStatus");
  if(!table) return;
  const tbody = table.querySelector("tbody");
  if(!tbody) return;
  tbody.innerHTML = "";
  if(!TG_BF.length && !XMAS.length){
    const helper = document.querySelector('[data-special-help]');
    if(helper) helper.textContent = 'No special weeks in this contest.';
    const wrapper = table.parentElement;
    if(wrapper){
      wrapper.innerHTML = '<div class="tiny muted">No special-week requirements for this contest.</div>';
    }
    return;
  }
  const week = state.data.meta.currentWeek;

  const mkAvailChip = (code, map) => `<span class="chip logo-chip">${cellLogo(code)}${TEAM_NAME[code]} <span class="muted">(${map[code]||""})</span></span>`;
  const mkAvailList = (codes, map) => codes.length
    ? codes.map(c=>mkAvailChip(c, map)).join("")
    : `<span class="muted tiny">none</span>`;
  const mkUsedList = (picks)=> picks.length
    ? picks.map(p=>{
        const res = String(p.result || 'P').toUpperCase();
        const info = resultInfo(res);
        const teamLabel = teamNameHtml(p.team, info.class);
        const detail = `${wLabel(p.week)} • ${resultDetailLabel(res)}`;
        return `<span class="chip logo-chip dim">${cellLogo(p.team)} ${teamLabel} <span class="muted">(${detail})</span></span>`;
      }).join("")
    : `<span class="muted tiny">none</span>`;

  for(const pl of state.data.players){
    const panelId = `avail-${cssSafe(pl.name)}`;
    const picksThrough = state.data.picks
      .filter(p=>p.player===pl.name && cmpWeek(p.week, week)<=0)
      .sort((a,b)=>cmpWeek(a.week,b.week));
    const usedUp = picksThrough.map(p=>p.team);
    const tg = usedUp.filter(t=>TG_BF.includes(t)).length;
    const xm = usedUp.filter(t=>XMAS.includes(t)).length;

    const tgBadge = tg>=TG_THRESHOLD?`<span class="chip info tiny">≥40%</span>`:
                    tg===(TG_THRESHOLD-1)?`<span class="chip warn tiny">↗ 40% threshold</span>`:"";
    const xmBadge = xm>=XMAS_THRESHOLD?`<span class="chip info tiny">≥40%</span>`:
                    xm===(XMAS_THRESHOLD-1)?`<span class="chip warn tiny">↗ 40% threshold</span>`:"";

    const tgAvail = TG_BF.filter(t=>!usedUp.includes(t));
    const xmAvail = XMAS.filter(t=>!usedUp.includes(t));
    const tgUsed = picksThrough.filter(p=>TG_BF.includes(p.team));
    const xmUsed = picksThrough.filter(p=>XMAS.includes(p.team));

    const panelTr = document.createElement("tr");
    panelTr.innerHTML = `
      <td colspan="5" style="padding-top:0;padding-bottom:0;">
        <div class="avail-panel" id="${panelId}" data-player="${htmlSafe(pl.name)}">
          <div class="avail-grid">
            <div class="avail-col">
              <h4>Thanksgiving + Black Friday (Available)</h4>
              <div class="chips">${mkAvailList(tgAvail, TG_MATCHUP_TAG)}</div>
              <div class="tiny muted" style="margin-top:6px">Used</div>
              <div class="chips">${mkUsedList(tgUsed)}</div>
            </div>
            <div class="avail-col">
              <h4>Christmas (Available)</h4>
              <div class="chips">${mkAvailList(xmAvail, XMAS_MATCHUP_TAG)}</div>
              <div class="tiny muted" style="margin-top:6px">Used</div>
              <div class="chips">${mkUsedList(xmUsed)}</div>
            </div>
          </div>
        </div>
      </td>`;

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <strong>${pl.name}</strong>
        <button class="toggle-btn" type="button" data-player="${htmlSafe(pl.name)}" data-target="${panelId}" aria-expanded="false" aria-controls="${panelId}">
          ${specialPanelLabel(false)}
        </button>
      </td>
      <td class="mono">${tg}/${TG_BF.length} ${tgBadge}</td>
      <td class="tiny"><button class="link-btn open-panel" type="button" data-player="${htmlSafe(pl.name)}" data-target="${panelId}" aria-expanded="false">View teams</button></td>
      <td class="mono">${xm}/${XMAS.length} ${xmBadge}</td>
      <td class="tiny"><button class="link-btn open-panel" type="button" data-player="${htmlSafe(pl.name)}" data-target="${panelId}" aria-expanded="false">View teams</button></td>
    `;

    tbody.appendChild(tr);
    tbody.appendChild(panelTr);
  }

  tbody.querySelectorAll(".avail-panel").forEach(panel=>{
    const player = panel.dataset.player;
    if(!player) return;
    if(sessionStorage.getItem(`open_avail_${player}`)==="1"){
      panel.classList.add("open");
      table.querySelectorAll(`[data-target="${panel.id}"], [aria-controls="${panel.id}"]`).forEach(btn=>{
        btn.setAttribute("aria-expanded", "true");
        if(btn.classList.contains("toggle-btn")){
          btn.innerHTML = specialPanelLabel(true);
        }
        if(btn.classList.contains("open-panel")){
          btn.textContent = "Hide teams";
        }
      });
    }
  });
}

function specialPanelLabel(open){
  return `<span class="chev">▸</span><span class="tiny muted">${open?"Hide teams":"Available teams"}</span>`;
}

/* ================= Hedge Tab ================= */
function decimalsFromAmerican(american){
  if(american===null || american===undefined || american==='') return null;
  const a = Number(american);
  if(Number.isNaN(a) || a===0) return null;
  return a>0 ? 1 + a/100 : 1 + 100/Math.abs(a);
}

function renderHedgeSelectors(){
  const selP = document.getElementById("hedgePlayer");
  const selW = document.getElementById("hedgeWeek");
  if(!selP || !selW) return;
  selP.innerHTML = ""; selW.innerHTML = "";

  state.data.players.forEach(p=>{
    const opt = document.createElement("option");
    opt.value = p.name; opt.textContent = p.name;
    selP.appendChild(opt);
  });

  Object.keys(state.data.meta.weekDates).forEach(w=>{
    const opt = document.createElement("option");
    opt.value = w; opt.textContent = wLabel(w);
    selW.appendChild(opt);
  });

  const desiredWeekRaw = state.hedgeWeek && Object.prototype.hasOwnProperty.call(state.data.meta.weekDates, state.hedgeWeek)
    ? state.hedgeWeek
    : String(state.data.meta.currentWeek);
  const desiredWeek = clampWeekValue(desiredWeekRaw);
  selW.value = desiredWeek;
  state.hedgeWeek = selW.value;

  const playerExists = state.data.players.some(p=>p.name===state.hedgePlayer);
  const desiredPlayer = playerExists ? state.hedgePlayer : (state.data.players[0]?.name || "");
  if(desiredPlayer) selP.value = desiredPlayer;

  selP.onchange = ()=>{ state.hedgePlayer = selP.value; renderHedge(); };
  selW.onchange = ()=>{
    const raw = Number(selW.value);
    const clamped = clampWeekValue(raw);
    if(clamped !== raw){ selW.value = String(clamped); }
    state.hedgeWeek = selW.value;
    renderHedge();
    lockFutureWeeksUI();
  };

  lockFutureWeeksUI();
}

function prettyPickRow(p){
  if(!p) return `<span class="muted">No pick for this week.</span>`;
  const res = String(p.result || 'P').toUpperCase();
  const info = resultInfo(res);
  const badge = resultChipHtml(res);
  const teamLabel = teamNameHtml(p.team, info.class);
  return `<div>${wLabel(p.week)} — ${cellLogo(p.team)} ${teamLabel} ${badge}</div>`;
}

function renderHedge(){
  const selP = document.getElementById("hedgePlayer");
  const selW = document.getElementById("hedgeWeek");
  const pickBox = document.getElementById("hedgePick");
  const badges = document.getElementById("hedgeBadges");
  if(!selP || !selW || !pickBox || !badges) return;
  const name = selP.value;
  const week = selW.value;
  if(!name || !week){
    pickBox.innerHTML = "";
    badges.textContent = "—";
    const matchupEl = document.getElementById("hcMatchup");
    if(matchupEl) matchupEl.innerHTML = "";
    return;
  }
  state.hedgePlayer = name;
  state.hedgeWeek = week;

  const current = state.data.picks.find(p=>p.player===name && String(p.week)===String(week));
  const usedSet = usedTeamsUpTo(state.data.picks, name, week);
  const amerEl = document.getElementById("hcAmer");
  const opponentInfo = current ? findOpponentInfo(week, current.team) : null;
  if(amerEl && opponentInfo && opponentInfo.ml!==null){ amerEl.value = String(opponentInfo.ml); }

  const opponentRow = current
    ? (opponentInfo
      ? `<div>Opponent: ${cellLogo(opponentInfo.team)}${TEAM_NAME[opponentInfo.team]} <span class="chip tiny">${opponentInfo.ml!==null?fmtML(opponentInfo.ml):"ML ?"}</span></div>`
      : `<div class="tiny muted">Opponent line not saved yet.</div>`)
    : "";

  pickBox.innerHTML = [
    `<div><strong>${name}</strong></div>`,
    prettyPickRow(current),
    opponentRow,
    `<div class="tiny muted" style="margin-top:6px">Used teams:</div>`,
    `<div class="chips">${usedSet.length? usedSet.map(t=>`<span class="chip logo-chip dim">${cellLogo(t)}${TEAM_NAME[t]}</span>`).join("") : "<span class='muted tiny'>none</span>"}</div>`
  ].join("");

  const matchupEl = document.getElementById("hcMatchup");
  if(matchupEl){
    if(current && opponentInfo){
      matchupEl.innerHTML = `
        <div class="hc-team">${cellLogo(current.team,true)}${TEAM_NAME[current.team]}</div>
        <div class="hc-vs">vs</div>
        <div class="hc-team">${cellLogo(opponentInfo.team,true)}${TEAM_NAME[opponentInfo.team]}</div>
      `;
    }else if(current){
      matchupEl.innerHTML = `
        <div class="hc-team">${cellLogo(current.team,true)}${TEAM_NAME[current.team]}</div>
        <div class="hc-vs">vs</div>
        <div class="hc-team muted">Unknown</div>
      `;
    }else{
      matchupEl.innerHTML = "";
    }
  }

  const explain = document.getElementById("hcExplain");
  if(explain){
    if(current){
      explain.dataset.myTeam = current.team;
      explain.dataset.oppTeam = opponentInfo?.team || "";
    }else{
      delete explain.dataset.myTeam;
      delete explain.dataset.oppTeam;
    }
  }

  const fallbackMl = amerEl && amerEl.value!=="" ? Number(amerEl.value) : null;
  const displayML = opponentInfo?.ml ?? fallbackMl;
  const oppLogoSmall = opponentInfo ? cellLogo(opponentInfo.team) : "";
  const oppName = opponentInfo ? (TEAM_NAME[opponentInfo.team] || opponentInfo.team) : "";
  let badgeHTML = "—";

  if(current){
    if(String(week)==="3"){
      const status = FIELD_RESULTS_W3[current.team];
      const statusClass = status==='L' ? 'loss' : status==='W' ? 'win' : 'pending';
      const decoratedTeam = teamNameHtml(current.team, statusClass);
      const cnt = (FIELD_W3 && FIELD_W3[current.team])||0;
      const activeTotal = Object.entries(FIELD_W3).reduce((sum,[team,count])=>{
        if(team==="NOPICK" || FIELD_RESULTS_W3[team]==='W' || FIELD_RESULTS_W3[team]==='L') return sum;
        return sum + count;
      },0) || 1;
      const fieldMsg = status==='W'
        ? `${decoratedTeam} ${resultSymbolHtml('W')} already won`
        : (status==='L'
          ? `${decoratedTeam} ${resultSymbolHtml('L')} already lost`
          : (()=>{
              const fieldPct = Math.round((cnt/activeTotal)*1000)/10;
              return `${decoratedTeam} field: ${fieldPct}%`;
            })());
      if(opponentInfo){
        const mlPart = displayML!==null ? ` ${fmtML(displayML)}` : "";
        badgeHTML = `${oppLogoSmall}${oppName}${mlPart} • ${fieldMsg}`;
      }else if(displayML!==null){
        badgeHTML = `Opponent ML ${fmtML(displayML)} • ${fieldMsg}`;
      }else{
        badgeHTML = `${fieldMsg} — opponent ML pending`;
      }
    }else if(opponentInfo){
      badgeHTML = `Hedge vs ${oppLogoSmall}${oppName}`;
      if(displayML!==null){
        badgeHTML += ` • ML ${fmtML(displayML)}`;
      }
    }else if(displayML!==null){
      badgeHTML = `Opponent ML ${fmtML(displayML)}`;
    }else{
      badgeHTML = `Opponent ML pending`;
    }
  }

  badges.innerHTML = badgeHTML;

  const warn = document.getElementById("hcWarn");
  if(warn){ warn.textContent = ""; warn.className = "note"; }

  renderHedgeCalc();
}

function renderHedgeCalc(){
  const amerEl = document.getElementById("hcAmer");
  const stakeEl = document.getElementById("hcStake");
  const pEl = document.getElementById("hcPwin");
  const eqEl = document.getElementById("hcEquity");
  const warn = document.getElementById("hcWarn");
  const tbody = document.querySelector("#hcTable tbody");
  const sumEl = document.getElementById("hcSummary");
  const whyEl = document.getElementById("hcWhy");
  const explain = document.getElementById("hcExplain");
  if(!stakeEl || !pEl || !tbody) return;

  const decimal = Math.max(1.01, decimalsFromAmerican(amerEl?.value) || 2.20);
  const stake = Math.max(0, Number(stakeEl.value)||0);
  const pWin = Math.min(0.99, Math.max(0.01, (Number(pEl.value)||60)/100));
  const equity = Math.max(0, Number(eqEl?.value)||0);
  const buyIn = Math.max(0, Number(document.getElementById("hcBuyin")?.value)||0);

  if(warn && !warn.textContent){ warn.className = "note"; }

  if(amerEl && (!amerEl.value || amerEl.value==="0")){
    const american = decimal>=2 ? Math.round((decimal-1)*100) : Math.round(-100/(decimal-1));
    amerEl.placeholder = fmtML(american);
  }

  const netWin = -stake;
  const netLose = stake*(decimal-1);
  const afterWin = (equity - stake) - buyIn;
  const afterLose = netLose - buyIn;
  const evHedge = pWin*netWin + (1-pWin)*netLose;
  const evWin = pWin * afterWin;
  const evLose = (1-pWin) * afterLose;
  const evTotal = evWin + evLose;
  const floorEqualize = equity ? equity*(decimal-1)/decimal : null;

  const fmtMoney = val => {
    if(!Number.isFinite(val)) return "—";
    const abs = Math.abs(val).toFixed(2);
    const sign = val>0?"+":val<0?"-":"";
    return `${sign}$${abs}`;
  };
  const classFor = val => val>0?"profit":val<0?"loss":"";

  tbody.innerHTML = `
    <tr>
      <td>Your pick <strong>WINS</strong></td>
      <td class="mono">${fmtMoney(netWin)}</td>
      <td class="mono ${classFor(afterWin)}">${fmtMoney(afterWin)}</td>
      <td class="mono ${classFor(evWin)}">${fmtMoney(evWin)}</td>
    </tr>
    <tr>
      <td>Your pick <strong>LOSES</strong></td>
      <td class="mono">${fmtMoney(netLose)}</td>
      <td class="mono ${classFor(afterLose)}">${fmtMoney(afterLose)}</td>
      <td class="mono ${classFor(evLose)}">${fmtMoney(evLose)}</td>
    </tr>
    <tr>
      <td class="tiny muted">Expected Value (overall)</td>
      <td class="mono ${classFor(evHedge)}">${fmtMoney(evHedge)}</td>
      <td class="mono ${classFor(evTotal)}">${fmtMoney(evTotal)}</td>
      <td class="mono ${classFor(evTotal)}">${fmtMoney(evTotal)}</td>
    </tr>
    ${floorEqualize!==null?`<tr><td class="tiny muted">Equalized floor reference</td><td></td><td class="tiny muted">≈ $${floorEqualize.toFixed(2)}</td><td></td></tr>`:""}
  `;

  const mlRaw = amerEl?.value?.trim() || "";
  const ml = mlRaw ? Number(mlRaw) : null;
  const mlProfit = (american, stakeAmount)=>{
    if(american===null || Number.isNaN(american)) return null;
    if(american > 0) return stakeAmount * (american/100);
    if(american < 0) return stakeAmount * (100/Math.abs(american));
    return null;
  };
  const payout = mlProfit(ml, stake);
  const totalReturn = payout!==null ? payout + stake : null;
  const floorBeforeBuy = Math.min(equity - stake, stake*(decimal-1));
  const floorAfterBuy = floorBeforeBuy - buyIn;

  if(sumEl){
    const oppTeam = explain?.dataset.oppTeam || "";
    const oppLogo = oppTeam ? cellLogo(oppTeam,true) : "";
    const oppName = oppTeam ? (TEAM_NAME[oppTeam] || oppTeam) : "";
    let summaryLogo = oppTeam ? oppLogo : "";
    let summaryText = "";

    if(stake <= 0){
      summaryLogo = "";
      summaryText = "Stake is $0 — no hedge in place yet.";
    }else if(ml===null || Number.isNaN(ml)){
      const lead = oppName ? `Hedge vs ${oppName}. ` : "";
      summaryText = `${lead}Wager <strong>$${stake.toFixed(2)}</strong>. Add an opponent ML to see exact payouts. Floor before buy-in: <strong>$${floorBeforeBuy.toFixed(2)}</strong>.`;
    }else if(payout!==null){
      const lead = oppName ? `Hedge vs ${oppName}. ` : "";
      summaryText = `${lead}Wager <strong>$${stake.toFixed(2)}</strong> on <strong>${fmtML(ml)}</strong>. If your pick loses you receive <strong>$${totalReturn.toFixed(2)}</strong> (profit +$${payout.toFixed(2)}); if it wins you drop <strong>$${stake.toFixed(2)}</strong>. Floor before buy-in ≈ <strong>$${floorBeforeBuy.toFixed(2)}</strong> (${floorAfterBuy >=0?"after-buy-in floor":"after-buy-in shortfall"} ${floorAfterBuy>=0?"+":"-"}$${Math.abs(floorAfterBuy).toFixed(2)}).`;
    }else{
      const lead = oppName ? `Hedge vs ${oppName}. ` : "";
      summaryText = `${lead}Wager $${stake.toFixed(2)} at the opponent ML. Floor before buy-in: $${floorBeforeBuy.toFixed(2)}.`;
    }

    sumEl.innerHTML = `${summaryLogo}<span>${summaryText}</span>`;
  }

  if(whyEl){
    const maxFloor = equity*(decimal-1)/decimal;
    let msg = "";
    if(stake <= 0){
      msg = "No hedge yet. Equalize locks a guaranteed floor; Target Floor or Lock buttons set the smallest stake for a goal.";
    }else if(Math.abs(floorBeforeBuy - maxFloor) < 1e-2){
      msg = `Stake matches the Equalize outcome. Both paths end around $${maxFloor.toFixed(2)} before buy-in.`;
    }else if(floorAfterBuy >= 0){
      msg = `This stake covers your buy-in even if the hedge loses — you're guaranteed at least $${floorAfterBuy.toFixed(2)} after buy-in.`;
    }else{
      msg = `Current stake doesn’t cover the buy-in if your pick wins (you’d net -$${Math.abs(floorAfterBuy).toFixed(2)}). Consider Lock Buy-In or Equalize if you want certainty.`;
    }
    whyEl.textContent = `${msg} Hedging trades upside for certainty; use it when the opponent price is good or your pick feels shaky.`;
  }
}

/* ===== Hedge Engine (American ML presets) ===== */
const HEDGE_DOM = {
  weekSel: 'hedgeWeek',
  teamSel: 'hedgeTeam',
  modeSel: 'hedgeMode',
  oppMlInput: 'oppML',
  spInput: 'spreadPrice',
  entryInput: 'entryFee',
  recouped: 'recoupedSoFar',
  outGrid: 'hedgeGrid'
};

const HEDGE_MODE_INFO = {
  CHIRAQI: { label: 'Chiraqi Dome', blurb: 'Full moneyline hedge — every dollar rides the opponent ML.' },
  SOLDIER: { label: 'Soldier Cover', blurb: 'Even 50/50 split between opponent ML and spread to balance win-or-cover.' },
  OBLOCK: { label: 'O-Block Lock', blurb: 'Seventy-five / twenty-five ML-heavy blend that tightens the downside.' },
  CCC: { label: 'Capone Cover Collector', blurb: 'Twenty-five / seventy-five spread-weighted mix to bank when the dog covers.' }
};

const HEDGE_INDUSTRY_INFO = {
  ENTRYFEE: { label: 'Entry Fee Recovery', blurb: 'Size hedge so if you lose, you get your buy-in back.' },
  FLAT: { label: 'Flat Target', blurb: 'Always aim for the same fixed payout on a KO.' },
  KELLY: { label: 'Kelly Criterion', blurb: 'Stake fraction based on odds and your edge probability.' }
};

function updateHedgeModeNote(mode){
  const note = document.getElementById('hedgeModeNote');
  if(!note) return;
  const key = (mode || 'CHIRAQI').toUpperCase();
  const meta = HEDGE_MODE_INFO[key] || HEDGE_MODE_INFO.CHIRAQI;
  note.innerHTML = `<strong>${meta.label}</strong> — ${meta.blurb}`;
}

function updateIndustryNote(mode){
  const note = document.getElementById('hedgeIndustryNote');
  if(!note) return;
  const key = (mode || 'ENTRYFEE').toUpperCase();
  const meta = HEDGE_INDUSTRY_INFO[key] || HEDGE_INDUSTRY_INFO.ENTRYFEE;
  note.innerHTML = `<strong>${meta.label}</strong> — ${meta.blurb}`;
}

document.getElementById('hedgeMode')?.addEventListener('change', e => updateHedgeModeNote(e.target.value));
document.getElementById('hedgeIndustryMode')?.addEventListener('change', e => updateIndustryNote(e.target.value));

const HEDGE_EMPTY = () => ({
  stakeML: 0,
  stakeSP: 0,
  profit_dog_wins: 0,
  profit_dog_covers: 0,
  loss_fav_covers: 0
});

const payPerDollar = american => {
  const a = Number(american);
  if(!Number.isFinite(a) || a === 0) return 0;
  return a > 0 ? a/100 : 100/Math.abs(a);
};

const impliedProb = american => {
  const a = Number(american);
  if(!Number.isFinite(a) || a === 0) return 0;
  return a > 0 ? 100/(a+100) : Math.abs(a)/(Math.abs(a)+100);
};

function weeklyHedgeTarget(entryFee, week, recouped = 0){
  const E = Math.max(0, Number(entryFee) || 0);
  const w = Number(week);
  const R = Math.max(0, Number(recouped) || 0);
  if(!Number.isFinite(w)) return Math.max(0, E - R);

  if(w <= 11){
    const need = Math.max(0, E - R);
    const weeksLeftToTG = Math.max(1, 12 - w);
    const amortized = need / weeksLeftToTG;
    const rampMin = 0.08 * E * Math.pow(1.15, Math.max(0, w-1));
    return Math.max(amortized, rampMin);
  }
  if(w <= 14){
    return Math.max(0.35 * E, 0.30 * E * Math.pow(1.25, w - 12));
  }
  return Math.max(0.60 * E, 0.45 * E * Math.pow(1.30, w - 15));
}

const hedgeWithFullML = (target, oppML) => {
  const pML = payPerDollar(oppML);
  if(pML <= 0) return HEDGE_EMPTY();
  const stakeML = target / pML;
  return {
    stakeML,
    stakeSP: 0,
    profit_dog_wins: target,
    profit_dog_covers: -stakeML,
    loss_fav_covers: -stakeML
  };
};

const hedgeSoldierCover = (target, oppML, spreadPrice) => {
  const pML = payPerDollar(oppML);
  const pSP = payPerDollar(spreadPrice);
  if(pML <= 0 || pSP <= 0) return HEDGE_EMPTY();

  const stakeML = target / (1 + pML);
  const stakeSP = target / (pSP * (1 + pML));
  return {
    stakeML,
    stakeSP,
    profit_dog_wins: target,
    profit_dog_covers: stakeSP * pSP - stakeML,
    loss_fav_covers: -(stakeML + stakeSP)
  };
};

const hedgeOBlock = (target, oppML, spreadPrice, ratio = 0.75) => {
  const pML = payPerDollar(oppML);
  const pSP = payPerDollar(spreadPrice);
  if(pML <= 0 || pSP <= 0) return HEDGE_EMPTY();

  const totalStake = target / (ratio * pML + (1 - ratio) * pSP);
  const stakeML = ratio * totalStake;
  const stakeSP = (1 - ratio) * totalStake;
  return {
    stakeML,
    stakeSP,
    profit_dog_wins: target,
    profit_dog_covers: stakeSP * pSP - stakeML,
    loss_fav_covers: -totalStake
  };
};

const hedgeCapone = (target, oppML, spreadPrice, ratio = 0.75) => {
  const pML = payPerDollar(oppML);
  const pSP = payPerDollar(spreadPrice);
  if(pML <= 0 || pSP <= 0) return HEDGE_EMPTY();

  const totalStake = target / ((1 - ratio) * pML + ratio * pSP);
  const stakeML = (1 - ratio) * totalStake;
  const stakeSP = ratio * totalStake;
  return {
    stakeML,
    stakeSP,
    profit_dog_wins: target,
    profit_dog_covers: stakeSP * pSP - stakeML,
    loss_fav_covers: -totalStake
  };
};

function renderHedgeGridOutput(outcome, container){
  const el = document.getElementById(container || HEDGE_DOM.outGrid);
  if(!el) return;
  const safe = outcome || HEDGE_EMPTY();
  const rows = [
    ['Stake ML', safe.stakeML],
    ['Stake Spread', safe.stakeSP],
    ['Dog Wins', safe.profit_dog_wins],
    ['Dog Covers', safe.profit_dog_covers],
    ['Fav Wins & Covers', safe.loss_fav_covers]
  ];
  el.innerHTML = `
    <table class="mini">
      <tbody>
        ${rows.map(([label,val])=>{
          const num = Number(val) || 0;
          const fmt = (num>=0?'+':'-') + '$' + Math.abs(num).toFixed(2);
          return `<tr><td>${label}</td><td style="text-align:right">${fmt}</td></tr>`;
        }).join('')}
      </tbody>
    </table>`;
}

function runHedgeCalcStandalone(){
  const weekRaw = document.getElementById(HEDGE_DOM.weekSel)?.value;
  const week = Number(weekRaw);
  const mode = (document.getElementById(HEDGE_DOM.modeSel)?.value || 'CHIRAQI').toUpperCase();
  updateHedgeModeNote(mode);
  const oppML = Number(document.getElementById(HEDGE_DOM.oppMlInput)?.value || 0);
  const spreadPrice = Number(document.getElementById(HEDGE_DOM.spInput)?.value || -110);
  const entryFee = Number(document.getElementById(HEDGE_DOM.entryInput)?.value || 1300);
  const recouped = Number(document.getElementById(HEDGE_DOM.recouped)?.value || 0);
  const target = weeklyHedgeTarget(entryFee, week, recouped);

  let result;
  switch(mode){
    case 'CHIRAQI':
      result = hedgeWithFullML(target, oppML);
      break;
    case 'SOLDIER':
      result = hedgeSoldierCover(target, oppML, spreadPrice);
      break;
    case 'OBLOCK':
      result = hedgeOBlock(target, oppML, spreadPrice);
      break;
    case 'CCC':
    default:
      result = hedgeCapone(target, oppML, spreadPrice);
      break;
  }

  renderHedgeGridOutput(result, HEDGE_DOM.outGrid);
  return result;
}

function initStandaloneHedgeCalc(){
  const inputs = [
    HEDGE_DOM.weekSel,
    HEDGE_DOM.teamSel,
    HEDGE_DOM.modeSel,
    HEDGE_DOM.oppMlInput,
    HEDGE_DOM.spInput,
    HEDGE_DOM.entryInput,
    HEDGE_DOM.recouped
  ];
  inputs.forEach(id=>{
    const el = document.getElementById(id);
    if(el){
      ['change','input'].forEach(evt=>{
        el.addEventListener(evt, runHedgeCalcStandalone);
      });
    }
  });
  updateIndustryNote(document.getElementById('hedgeIndustryMode')?.value);
  runHedgeCalcStandalone();
  window.runHedgeCalcStandalone = runHedgeCalcStandalone;
}

function bindHedgeCalcInputs(){
  const ids = ["hcAmer","hcStake","hcPwin","hcEquity","hcBuyin","hcFloor","hcProfit"];
  const warn = document.getElementById("hcWarn");
  const amerEl = document.getElementById("hcAmer");
  const stakeEl = document.getElementById("hcStake");
  const eqEl = document.getElementById("hcEquity");
  const floorEl = document.getElementById("hcFloor");
  const buyEl = document.getElementById("hcBuyin");
  const profitEl = document.getElementById("hcProfit");
  const cleanWarn = (msg="")=>{
    if(!warn) return;
    warn.textContent = msg;
    warn.className = msg?"note warn":"note";
  };
  const handleInput = ()=>{ cleanWarn(); renderHedgeCalc(); };
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", handleInput);
  });

  const eqBtn = document.getElementById("btnEqualize");
  const targetBtn = document.getElementById("btnTarget");
  const lockBtn = document.getElementById("btnLock");
  const profitBtn = document.getElementById("btnProfit");

  const decimalValue = ()=>Math.max(1.01, decimalsFromAmerican(amerEl?.value) || 2.20);
  const equityValue = ()=>Math.max(0, Number(eqEl?.value)||0);
  const applyFloorTarget = (floorTarget, label)=>{
    const decimal = decimalValue();
    const equity = equityValue();
    const maxFloor = equity*(decimal-1)/decimal;
    if(floorTarget > maxFloor + 1e-6){
      cleanWarn(`${label} $${floorTarget.toFixed(2)} not feasible. Max floor ≈ $${maxFloor.toFixed(2)}.`);
      return false;
    }
    const minStake = floorTarget/(decimal-1);
    const maxStake = Math.max(0, equity - floorTarget);
    if(minStake > maxStake + 1e-6){
      cleanWarn(`${label} $${floorTarget.toFixed(2)} not feasible. Max floor ≈ $${maxFloor.toFixed(2)}.`);
      return false;
    }
    const stake = Math.min(Math.max(minStake, 0), maxStake);
    if(stakeEl){ stakeEl.value = stake.toFixed(2); }
    cleanWarn(`${label} $${floorTarget.toFixed(2)} locked with min stake ≈ $${stake.toFixed(2)} (max floor ≈ $${maxFloor.toFixed(2)}).`);
    renderHedgeCalc();
    return true;
  };

  eqBtn?.addEventListener("click", ()=>{
    const decimal = decimalValue();
    const equity = equityValue();
    const stake = equity / decimal;
    if(stakeEl){ stakeEl.value = stake.toFixed(2); }
    const floor = equity*(decimal-1)/decimal;
    cleanWarn(`Equalize: play ≈ $${stake.toFixed(2)} to lock floor ≈ $${floor.toFixed(2)}.`);
    renderHedgeCalc();
  });

  targetBtn?.addEventListener("click", ()=>{
    const floorTarget = Math.max(0, Number(floorEl?.value)||0);
    applyFloorTarget(floorTarget, "Target floor");
  });

  lockBtn?.addEventListener("click", ()=>{
    const buyIn = Math.max(0, Number(buyEl?.value)||0);
    applyFloorTarget(buyIn, "Lock Buy-In");
  });

  profitBtn?.addEventListener("click", ()=>{
    const buyIn = Math.max(0, Number(buyEl?.value)||0);
    const profit = Math.max(0, Number(profitEl?.value)||0);
    const floorTarget = buyIn + profit;
    applyFloorTarget(floorTarget, "Lock Profit");
  });
}

/* ===== Rooting Guide (Week 3 field data) ===== */
const FIELD_W3 = {};
const FIELD_RESULTS_W3 = {};
const FIELD_W3_TOTAL = 0;

function groupWeekExposure(week){
  const exp = {};
  for(const pick of state.data.picks){
    if(String(pick.week)!==String(week)) continue;
    const res = String(pick.result || 'P').toUpperCase();
    if(res === 'W' || res === 'L' || res === 'T') continue;
    exp[pick.team] = (exp[pick.team]||0)+1;
  }
  return exp;
}

function leverageList(week, fieldOverride=null, statusOverride={}){
  const field = fieldOverride || (week===3 ? FIELD_W3 : null);
  if(!field) return [];
  const status = statusOverride || {};
  const entries = Object.entries(field).filter(([team,count])=> team!=="NOPICK" && status[team] !== "W" && status[team] !== "L" && count>0);
  const totalField = entries.reduce((sum,[,count])=>sum+count,0) || 1;
  const group = groupWeekExposure(week);
  const rows = [];
  entries.forEach(([team, fieldCount])=>{
    const fieldPct = fieldCount / totalField;
    const groupCount = group[team] || 0;
    rows.push({
      outcome: `${TEAM_NAME[team]} lose`,
      fieldImpact: fieldPct,
      groupExposure: groupCount,
      why: groupCount===0 ? "We faded this chalk — full leverage" : "Field loses big; we drop some too"
    });
    rows.push({
      outcome: `${TEAM_NAME[team]} win`,
      fieldImpact: -fieldPct,
      groupExposure: groupCount,
      why: groupCount>0 ? "We stay alive with the crowd; low leverage" : "Field keeps equity while we still chase"
    });
  });
  rows.sort((a,b)=>b.fieldImpact - a.fieldImpact);
  return rows.slice(0,6);
}

function renderRooting(){
  const w = state.data.meta.currentWeek;
  const weekLabel = wLabel(w);
  const weekNode = document.getElementById("root-week");
  if(weekNode) weekNode.textContent = weekLabel;
  const { impliedNow, impliedIfLose, delta } = impliedValueContext();
  renderRootingCallout(impliedNow, impliedIfLose, delta);

  const rawField = w===3 ? FIELD_W3 : null;
  const fieldStatus = w===3 ? FIELD_RESULTS_W3 : {};
  const field = rawField ? {...rawField} : null;
  const groupExp = groupWeekExposure(w);
  const groupSize = state.data.players.length || 0;

  let chalkTeam = null;
  if(field){
    for(const [team,count] of Object.entries(field)){
      if(team === "NOPICK" || fieldStatus[team]==='W' || fieldStatus[team]==='L' || count<=0) continue;
      if(chalkTeam===null || count > field[chalkTeam]) chalkTeam = team;
    }
  }

  const chalkGroupCount = chalkTeam ? (groupExp[chalkTeam]||0) : 0;
  const activeTotal = field ? Object.entries(field).reduce((sum,[team,count])=>{
    if(team==="NOPICK" || fieldStatus[team]==='W' || fieldStatus[team]==='L') return sum;
    return sum + count;
  },0) || 1 : 1;
  const chalkFieldPct = chalkTeam && field ? field[chalkTeam] / activeTotal : 0;

  const chalkNode = document.getElementById("kpi-chalk");
  const fieldNode = document.getElementById("kpi-field");
  const chalkLoseNode = document.getElementById("kpi-chalklose");
  if(chalkNode) chalkNode.textContent = chalkTeam ? `${chalkGroupCount}/${groupSize} on ${TEAM_NAME[chalkTeam]}` : "n/a";
  if(fieldNode) fieldNode.textContent = chalkTeam ? `${TEAM_NAME[chalkTeam]} — ${(chalkFieldPct*100).toFixed(1)}%` : "n/a";
  if(chalkLoseNode) chalkLoseNode.textContent = chalkTeam ? `${(chalkFieldPct*100).toFixed(1)}%` : "n/a";

  const tbody = document.querySelector("#root-table tbody");
  if(tbody){
    tbody.innerHTML = "";
    leverageList(w, field, fieldStatus).forEach(row=>{
      const pct = (row.fieldImpact*100).toFixed(1);
      const pctNum = parseFloat(pct);
      const tr = document.createElement("tr");
      if(row.groupExposure>0) tr.classList.add("used");
      tr.innerHTML = `
        <td>${row.outcome}</td>
        <td class="mono ${pctNum>0?'badge-good':pctNum<0?'badge-bad':''}">${pctNum>0?'+':''}${pct}</td>
        <td class="mono">${row.groupExposure||0}</td>
        <td class="tiny muted">${row.why}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  const panel = document.getElementById("ifttt");
  if(panel){
    if(!field){
      panel.innerHTML = `<span class="muted tiny">No field data loaded for ${weekLabel} yet.</span>`;
    }else{
      const lines = [];
      if(chalkTeam){
        lines.push(`IF <strong>${TEAM_NAME[chalkTeam]}</strong> <span class="badge-bad">lose</span> THEN <span class="badge-good">${(chalkFieldPct*100).toFixed(0)}%</span> of field drops ${chalkGroupCount?`(we lose ${chalkGroupCount}).`:`(we lose 0).`}`);
      }
      let maxEntryTeam = null;
      let maxEntryCount = -1;
      for(const [team,count] of Object.entries(groupExp)){
        if(fieldStatus[team]==='W' || fieldStatus[team]==='L') continue;
        if(count > maxEntryCount){
          maxEntryCount = count;
          maxEntryTeam = team;
        }
      }
      if(maxEntryTeam){
        const fieldPct = field[maxEntryTeam]? (field[maxEntryTeam]/activeTotal)*100 : 0;
        lines.push(`IF <strong>${TEAM_NAME[maxEntryTeam]}</strong> <span class="badge-bad">lose</span> THEN <strong>${maxEntryCount}</strong> of our entries out (field hit ~${fieldPct.toFixed(0)}%).`);
      }
      let bestFadeTeam = null;
      let bestFadePct = -1;
      if(field){
        for(const [team,count] of Object.entries(field)){
          if(team === "NOPICK" || fieldStatus[team]==='W' || fieldStatus[team]==='L') continue;
          if((groupExp[team]||0)===0){
            const pct = count / activeTotal;
            if(pct > bestFadePct){
              bestFadePct = pct;
              bestFadeTeam = team;
            }
          }
        }
      }
      if(bestFadeTeam){
        lines.push(`IF <strong>${TEAM_NAME[bestFadeTeam]}</strong> <span class="badge-bad">lose</span> THEN max leverage for us (0 group risk; field -${(bestFadePct*100).toFixed(0)}%).`);
      }
      const playedWins = Object.entries(fieldStatus).filter(([,res])=>res==='W');
      const playedLosses = Object.entries(fieldStatus).filter(([,res])=>res==='L');
      const decidedWinsEntries = Array.from(new Set(state.data.picks
        .filter(p=>String(p.week)==='3' && fieldStatus[p.team]==='W')
        .map(p=>p.player)));
      const decidedLossEntries = Array.from(new Set(state.data.picks
        .filter(p=>String(p.week)==='3' && fieldStatus[p.team]==='L')
        .map(p=>p.player)));
      const decidedBits = [];
      if(playedWins.length){
        const teams = playedWins.map(([team])=>`${teamNameHtml(team,'win')} ${resultSymbolHtml('W')}`).join(", ");
        const note = decidedWinsEntries.length ? ` (secured for ${decidedWinsEntries.join(", ")})` : "";
        decidedBits.push(`${teams}${note}`);
      }
      if(playedLosses.length){
        const teams = playedLosses.map(([team])=>`${teamNameHtml(team,'loss')} ${resultSymbolHtml('L')}`).join(", ");
        const note = decidedLossEntries.length ? ` (out: ${decidedLossEntries.join(", ")})` : "";
        decidedBits.push(`${teams}${note}`);
      }
      const decidedNote = decidedBits.length
        ? `<div class="tiny muted">Already decided: ${decidedBits.join(" • ")}. Impact removed from leverage.</div>`
        : "";
      panel.innerHTML = (lines.length? lines.map(line=>`<div class="tiny">${line}</div>`).join("") : `<span class="muted tiny">No leverage scenarios available.</span>`) + decidedNote;
    }
  }
}

function cssSafe(s){ return String(s).toLowerCase().replace(/[^a-z0-9]+/g,"-"); }
function htmlSafe(s){ return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;"); }

/* ===== Make Picks Panel ===== */
function renderPickSelectors(){
  const weekSel = document.getElementById("pickWeek");
  const playerSel = document.getElementById("pickPlayer");
  const teamSel = document.getElementById("pickTeam");
  const saveBtn = document.getElementById("savePick");
  const controlsWrap = document.getElementById("pickControls");
  const tilesWrap = document.getElementById("availabilityTiles");
  let lockMsg = document.getElementById("pickLockBanner");
  weekSel.innerHTML = ""; playerSel.innerHTML = ""; teamSel.innerHTML = "";

  for(const w of weekOrder()){
    const opt = document.createElement("option"); opt.value = w; opt.textContent = wLabel(w);
    if(String(w)===String(state.data.meta.currentWeek)) opt.selected = true;
    weekSel.appendChild(opt);
  }
  for(const p of state.data.players){
    const opt = document.createElement("option"); opt.value = p.name; opt.textContent = p.name;
    playerSel.appendChild(opt);
  }
  const ensurePickLockBanner = ()=>{
    if(lockMsg || !controlsWrap) return lockMsg;
    lockMsg = document.createElement('div');
    lockMsg.id = 'pickLockBanner';
    lockMsg.style.cssText = 'margin:.5rem 0;padding:.5rem .75rem;border-radius:8px;background:#fff4cc;border:1px solid #ffd66b;font:500 13px system-ui;color:#614300;';
    controlsWrap.after(lockMsg);
    return lockMsg;
  };
  const updateLockState = ()=>{
    const locked = isWeekLocked(weekSel.value);
    const msg = 'Week 4+ picks unlock Tue 12:01 AM ET.';
    Array.from(weekSel.options).forEach(opt=>{
      const optLocked = isWeekLocked(opt.value);
      opt.classList.toggle('is-locked', optLocked);
      opt.title = optLocked ? 'Locked until Tue 12:01 AM ET' : '';
    });
    if(controlsWrap) controlsWrap.style.opacity = locked ? 0.55 : 1;
    teamSel.disabled = locked;
    teamSel.classList.toggle('is-locked', locked);
    weekSel.classList.toggle('is-locked', locked);
    if(saveBtn){
      saveBtn.disabled = locked;
      saveBtn.classList.toggle('is-locked', locked);
      saveBtn.title = locked ? msg : '';
    }
    teamSel.title = locked ? msg : '';
    if(tilesWrap){
      tilesWrap.style.opacity = locked ? 0.4 : '';
      tilesWrap.style.pointerEvents = locked ? 'none' : '';
    }
    const banner = ensurePickLockBanner();
    if(banner){
      if(locked){
        const unlockAt = nextTuesdayAt0001ET();
        const fmt = unlockAt.toLocaleString('en-US', { timeZone:'America/New_York', hour:'numeric', minute:'2-digit', weekday:'short', month:'short', day:'numeric' });
        banner.textContent = `Week ${LOCKED_MAX_WEEK+1}+ picks unlock Tue 12:01 AM ET (${fmt}).`;
        banner.style.display = '';
      }else{
        banner.style.display = 'none';
      }
    }
  };
  window.updatePickLockState = updateLockState;
  const refreshTeams = ()=>{
    const w = weekSel.value; const name = playerSel.value;
    const avail = availableForWeek(state.data.picks, name, w);
    teamSel.innerHTML = "";
    avail.forEach(c=>{ const opt = document.createElement("option"); opt.value=c; opt.textContent=TEAM_NAME[c]; teamSel.appendChild(opt); });
    const tiles = tilesWrap || document.getElementById("availabilityTiles");
    if(tiles){
      tiles.innerHTML = NFL.map(code=>{
        const used = usedTeamsBeforeWeek(state.data.picks, name, w).includes(code);
        const inPool = isTG(w)? TG_BF.includes(code) : isXMAS(w)? XMAS.includes(code) : true;
        return `<div class="tile ${used||!inPool?'used':''}">${cellLogo(code,true)}${TEAM_NAME[code]}</div>`;
      }).join("");
    }
    updateLockState();
  };
  weekSel.onchange = refreshTeams;
  playerSel.onchange = refreshTeams;
  refreshTeams();

  if(saveBtn){
    saveBtn.onclick = ()=>{
      if(isWeekLocked(weekSel.value)){
        alert('Week 4+ picks unlock Tue 12:01 AM ET.');
        return;
      }
    const w = isNaN(Number(weekSel.value)) ? weekSel.value : Number(weekSel.value);
    const name = playerSel.value; const team = teamSel.value;
    if(!team){ alert("No team available for that entry/week."); return; }
    if(state.data.picks.find(p=>String(p.week)===String(w) && p.player===name)){ alert("This entry already has a pick for that week."); return; }
    state.data.picks.push({week:w, player:name, team, result:"P"});
    saveData(state.data); sessionStorage.clear(); renderAll();
    };
  }
}

/* ===== Week controls & init ===== */
function renderWeekSelects(){
  const sel = document.getElementById("weekSelect");
  if(!sel) return;
  sel.innerHTML = "";
  for(const w of weekOrder()){
    const opt = document.createElement("option"); opt.value = w; opt.textContent = wLabel(w);
    if(String(w)===String(state.data.meta.currentWeek)) opt.selected = true;
    sel.appendChild(opt);
  }
  sel.onchange = ()=>{
    state.data.meta.currentWeek = isNaN(Number(sel.value))? sel.value : Number(sel.value);
    saveData(state.data);
    renderAll();
  };
  const advBtn = document.getElementById("advanceWeek");
  if(advBtn){
    advBtn.onclick = ()=>{
      const order = weekOrder();
      const idx = order.indexOf(String(state.data.meta.currentWeek));
      const rawNext = order[Math.min(order.length-1, idx+1)];
      state.data.meta.currentWeek = isNaN(Number(rawNext))? rawNext : Number(rawNext);
      saveData(state.data);
      renderAll();
    };
  }
}

function renderAll(){
  renderHeader();
  renderWeekSelects();
  renderTracker();
  renderSpecialStatus();
  bindSpecialStatusFocus();
  const fallback = state.data.players.find(p=>p.name===state.specialFocus)?.name || state.data.players[0]?.name || "";
  if(fallback) setSpecialFocus(fallback);
  renderSpecialGames();
  renderPickSelectors();
  renderHedgeSelectors();
  renderHedge();
  renderRooting();
  document.getElementById("dataEditor").value = JSON.stringify(state.data, null, 2);
  thresholdAlerts();
  lockFutureWeeksUI();
}
function showTab(id){
  ["overview","rooting","hedge"].forEach(tab=>{
    document.getElementById("tab-"+tab)?.classList.toggle("active", tab===id);
    document.querySelector(`.tabbtn[data-tab="${tab}"]`)?.classList.toggle("active", tab===id);
  });
}
function initTabs(){
  document.querySelectorAll(".tabbtn").forEach(btn=>{
    btn.addEventListener("click",()=>{
      if(btn.dataset.tab) showTab(btn.dataset.tab);
    });
  });
}

document.addEventListener("DOMContentLoaded", ()=>{
  initTabs();
  bindHedgeCalcInputs();
  initStandaloneHedgeCalc();
  showTab("overview");
  renderAll();
  renderSCS();
  lockFutureWeeksUI();
  setInterval(lockFutureWeeksUI, 30000);
});
</script>
</body>
</html>
